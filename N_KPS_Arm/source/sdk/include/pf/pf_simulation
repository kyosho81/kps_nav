#ifndef _PF_SIMULATION_WANGHONGTAO_20151021_
#define _PF_SIMULATION_WANGHONGTAO_20151021_


#include <string>
#include <boost/thread.hpp>

#include "RobotStruct.h"
#include "buffer_con.hpp"
#include "Rand.hpp"
#include "merge_tf.h"


#define SIM_LASER 541
#define MIN_PATICLES 1024
#define MAX_PATICLES 1024

class GridMap;

typedef struct _SimLaser
{
	F32 x_;
	F32 y_;

}SimLaser;

typedef struct _SimLaser_tf
{
	F32 base_laser_cos_[LASER_COUNT];
	F32 base_laser_sin_[LASER_COUNT];

}SimLaser_tf;

typedef struct _SimparticleAW
{
	F32 x_;
	F32 y_;
	F32 th_;
	F32 aw_;

}SimparticleAW;


class pf_simulation{

public:
	pf_simulation();
	~pf_simulation();

	void update_init_pos();
	void update_motion_modle();
	bool update_resapmle();

	void init_particle();
	void init_pos(const SInit_Pos &pos);
	bool s_init_pos(const SInit_Pos &pos);
	void init_amcl_map(GridMap* shared_map);
	GridMap* get_amcl_map();
	void clear_import_data();

	//call back when interprocess_laser (50hz)
	void update_laser(const SLaser& laser);
	bool s_update_laser( const SLaser& laser );
	void set_base_laser(F32 x, F32 y ,F32 th);
	
	//call back when interprocess_chassis (20hz)
	void update_odom(const SOdomSpeed& new_odom);
	bool s_update_odom( const SOdomSpeed& new_odom );

	void set_min_rand(const F32 &crxy,const F32 &crth);
	void set_motion_rand(const F32 &crmod,const F32 &crmth,const F32&crot);
	

	void get_particle(SparticlePub &pub);
	//bool get_res_pos(SPos &pos);
	void bind_pub_gpos(boost::function<void( const SPos &pos)> fnc);
	void bind_pub_entropy(boost::function<void( const SAMCL_ENTROPY &amcl_entropy)> fnc);
	void destructor();


	void load_test_data();
	void test_update_laser();

private:
//laser
	void set_laser_tf(const SLaser& laser);
	void set_laser();
	F32 list_laser_range_[LASER_COUNT];
	F32 list_cal_cos_[LASER_COUNT];
	F32 list_cal_sin_[LASER_COUNT];

	CSBuffer<SLaser,1> new_laser_;


//  	SimLaser laser_[SIM_LASER];
//  	U32 used_laser_size_;
	SLaser_xy laser_;
 	SimLaser_tf laser_tf_;
	
	bool no_laser_tf_;
	SPos base_laser_;


//particle
	
	U32 checksize(U32 newsize);
	void clean_particles();
	void get_weight();
	void sort();
	bool cal_pos(std::vector<SimparticleAW> &sort_p,std::vector<F32> &sum_drop);
	
	void cal_entropy( const SPos &res_pos, std::vector<SimparticleAW> &samples);
	U32 check_health_resize();
	void resample(const std::vector<SimparticleAW> &sort_p,std::vector<F32> &sum_drop);
	MyRand rd_;
	SimparticleAW* particle_;

	U32 psize_;
	F32 top_per_;
	inline U32 get_map_weight(const F32& x,const F32& y);
	bool new_init_pos_;
	boost::mutex mu_init_;
	SInit_Pos init_pos_;

//publish
	SparticlePub pub_;

//map
	GridMap* amcl_map_;
	

//odom
	boost::mutex mu_odom_;
	bool get_diff();


	SOdomSpeed last_odom_;
	SOdomSpeed new_odom_;
	SPos diff_odom_;
	bool first_odom_;

	F32 delta_trans_;
	F32 delta_the_;
	
//odom random
	MyRand rxy_;
	MyRand rth_;

	F32 crxy_;
	F32 crth_;

//odom motion random
	MyRand rmod_;
	MyRand rmth_;
	MyRand rrot_;

// 	TimeRand rmod_;
// 	TimeRand rmth_;
// 	TimeRand rrot_;

	F32 crmod_;
	F32 crmth_;
	F32 crot_;
	
	SPos create_motion_diff(SPos diff_odom);
	SPos create_motion_diff(SPos diff_odom,boost::random::mt19937 &gen);
	SPos create_rand_diff(SPos diff_odom);
	bool check_particle(const F32 &gx,const F32 &gy);

	//amcl
	void set_res_pos(const SPos &pos);


	F32 max_x_;
	F32 min_x_;

	F32 max_y_;
	F32 min_y_;

	F32 max_th_;
	F32 min_th_;
	//hyper location ,merge odom and amcl
	merge_tf location_tf_;
	bool b_merge_odom_;

	boost::function< void( const SPos &pos )> fnc_pub_gpos_;
	boost::function< void( const SAMCL_ENTROPY &amcl_entropy )> fnc_pub_entropy_;
};

#endif//_PF_SIMULATION_WANGHONGTAO_20151021_

