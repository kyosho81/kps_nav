// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base.proto

#ifndef PROTOBUF_base_2eproto__INCLUDED
#define PROTOBUF_base_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "pallet_cargo.pb.h"
// @@protoc_insertion_point(includes)

namespace KPS {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_base_2eproto();
void protobuf_AssignDesc_base_2eproto();
void protobuf_ShutdownFile_base_2eproto();

class mp_odom_data;
class mp_pos_data;
class mp_vec_data;
class mp_schedule;
class mp_bind_action;
class mp_bind_io;
class mp_item_base;

enum mp_bind_io_Bind_IO_Type {
  mp_bind_io_Bind_IO_Type_NONE = 0,
  mp_bind_io_Bind_IO_Type_POR_INPUT_PT_PUT = 1,
  mp_bind_io_Bind_IO_Type_POR_INPUT_CG_GET = 2,
  mp_bind_io_Bind_IO_Type_POR_OUTPUT_PT_PUT = 3,
  mp_bind_io_Bind_IO_Type_POR_OUTPUT_CG_GET = 4,
  mp_bind_io_Bind_IO_Type_CUS_INPUT_CG_PUT = 5,
  mp_bind_io_Bind_IO_Type_CUS_INPUT_PT_GET = 6,
  mp_bind_io_Bind_IO_Type_CUS_OUTPUT_CG_PUT = 7,
  mp_bind_io_Bind_IO_Type_CUS_OUTPUT_PT_GET = 8,
  mp_bind_io_Bind_IO_Type_STO_INPUT_EMPTY = 9,
  mp_bind_io_Bind_IO_Type_STO_OUTPUT_EMPTY = 10,
  mp_bind_io_Bind_IO_Type_CHARGE_INPUT_ONOFF = 11,
  mp_bind_io_Bind_IO_Type_CHARGE_INPUT_VOLTAGE = 12,
  mp_bind_io_Bind_IO_Type_CHARGE_OUTPUT_ONOFF = 13
};
bool mp_bind_io_Bind_IO_Type_IsValid(int value);
const mp_bind_io_Bind_IO_Type mp_bind_io_Bind_IO_Type_Bind_IO_Type_MIN = mp_bind_io_Bind_IO_Type_NONE;
const mp_bind_io_Bind_IO_Type mp_bind_io_Bind_IO_Type_Bind_IO_Type_MAX = mp_bind_io_Bind_IO_Type_CHARGE_OUTPUT_ONOFF;
const int mp_bind_io_Bind_IO_Type_Bind_IO_Type_ARRAYSIZE = mp_bind_io_Bind_IO_Type_Bind_IO_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* mp_bind_io_Bind_IO_Type_descriptor();
inline const ::std::string& mp_bind_io_Bind_IO_Type_Name(mp_bind_io_Bind_IO_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    mp_bind_io_Bind_IO_Type_descriptor(), value);
}
inline bool mp_bind_io_Bind_IO_Type_Parse(
    const ::std::string& name, mp_bind_io_Bind_IO_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<mp_bind_io_Bind_IO_Type>(
    mp_bind_io_Bind_IO_Type_descriptor(), name, value);
}
// ===================================================================

class mp_odom_data : public ::google::protobuf::Message {
 public:
  mp_odom_data();
  virtual ~mp_odom_data();
  
  mp_odom_data(const mp_odom_data& from);
  
  inline mp_odom_data& operator=(const mp_odom_data& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mp_odom_data& default_instance();
  
  void Swap(mp_odom_data* other);
  
  // implements Message ----------------------------------------------
  
  mp_odom_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mp_odom_data& from);
  void MergeFrom(const mp_odom_data& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float th = 3;
  inline bool has_th() const;
  inline void clear_th();
  static const int kThFieldNumber = 3;
  inline float th() const;
  inline void set_th(float value);
  
  // required float vx = 4;
  inline bool has_vx() const;
  inline void clear_vx();
  static const int kVxFieldNumber = 4;
  inline float vx() const;
  inline void set_vx(float value);
  
  // required float vy = 5;
  inline bool has_vy() const;
  inline void clear_vy();
  static const int kVyFieldNumber = 5;
  inline float vy() const;
  inline void set_vy(float value);
  
  // required float vw = 6;
  inline bool has_vw() const;
  inline void clear_vw();
  static const int kVwFieldNumber = 6;
  inline float vw() const;
  inline void set_vw(float value);
  
  // @@protoc_insertion_point(class_scope:KPS.mp_odom_data)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float x_;
  float y_;
  float th_;
  float vx_;
  float vy_;
  float vw_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mp_odom_data* default_instance_;
};
// -------------------------------------------------------------------

class mp_pos_data : public ::google::protobuf::Message {
 public:
  mp_pos_data();
  virtual ~mp_pos_data();
  
  mp_pos_data(const mp_pos_data& from);
  
  inline mp_pos_data& operator=(const mp_pos_data& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mp_pos_data& default_instance();
  
  void Swap(mp_pos_data* other);
  
  // implements Message ----------------------------------------------
  
  mp_pos_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mp_pos_data& from);
  void MergeFrom(const mp_pos_data& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float th = 3;
  inline bool has_th() const;
  inline void clear_th();
  static const int kThFieldNumber = 3;
  inline float th() const;
  inline void set_th(float value);
  
  // @@protoc_insertion_point(class_scope:KPS.mp_pos_data)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float x_;
  float y_;
  float th_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mp_pos_data* default_instance_;
};
// -------------------------------------------------------------------

class mp_vec_data : public ::google::protobuf::Message {
 public:
  mp_vec_data();
  virtual ~mp_vec_data();
  
  mp_vec_data(const mp_vec_data& from);
  
  inline mp_vec_data& operator=(const mp_vec_data& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mp_vec_data& default_instance();
  
  void Swap(mp_vec_data* other);
  
  // implements Message ----------------------------------------------
  
  mp_vec_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mp_vec_data& from);
  void MergeFrom(const mp_vec_data& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // @@protoc_insertion_point(class_scope:KPS.mp_vec_data)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float x_;
  float y_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mp_vec_data* default_instance_;
};
// -------------------------------------------------------------------

class mp_schedule : public ::google::protobuf::Message {
 public:
  mp_schedule();
  virtual ~mp_schedule();
  
  mp_schedule(const mp_schedule& from);
  
  inline mp_schedule& operator=(const mp_schedule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mp_schedule& default_instance();
  
  void Swap(mp_schedule* other);
  
  // implements Message ----------------------------------------------
  
  mp_schedule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mp_schedule& from);
  void MergeFrom(const mp_schedule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);
  
  // required string sch_date = 2;
  inline bool has_sch_date() const;
  inline void clear_sch_date();
  static const int kSchDateFieldNumber = 2;
  inline const ::std::string& sch_date() const;
  inline void set_sch_date(const ::std::string& value);
  inline void set_sch_date(const char* value);
  inline void set_sch_date(const char* value, size_t size);
  inline ::std::string* mutable_sch_date();
  
  // required .KPS.mp_pallet_cargo pallet_cargo = 3;
  inline bool has_pallet_cargo() const;
  inline void clear_pallet_cargo();
  static const int kPalletCargoFieldNumber = 3;
  inline const ::KPS::mp_pallet_cargo& pallet_cargo() const;
  inline ::KPS::mp_pallet_cargo* mutable_pallet_cargo();
  
  // @@protoc_insertion_point(class_scope:KPS.mp_schedule)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool enable_;
  ::std::string* sch_date_;
  static const ::std::string _default_sch_date_;
  ::KPS::mp_pallet_cargo* pallet_cargo_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mp_schedule* default_instance_;
};
// -------------------------------------------------------------------

class mp_bind_action : public ::google::protobuf::Message {
 public:
  mp_bind_action();
  virtual ~mp_bind_action();
  
  mp_bind_action(const mp_bind_action& from);
  
  inline mp_bind_action& operator=(const mp_bind_action& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mp_bind_action& default_instance();
  
  void Swap(mp_bind_action* other);
  
  // implements Message ----------------------------------------------
  
  mp_bind_action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mp_bind_action& from);
  void MergeFrom(const mp_bind_action& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);
  
  // required bool enable = 2;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 2;
  inline bool enable() const;
  inline void set_enable(bool value);
  
  // required bool turn = 3;
  inline bool has_turn() const;
  inline void clear_turn();
  static const int kTurnFieldNumber = 3;
  inline bool turn() const;
  inline void set_turn(bool value);
  
  // required bool passing_bay = 4;
  inline bool has_passing_bay() const;
  inline void clear_passing_bay();
  static const int kPassingBayFieldNumber = 4;
  inline bool passing_bay() const;
  inline void set_passing_bay(bool value);
  
  // required bool task_replan = 5;
  inline bool has_task_replan() const;
  inline void clear_task_replan();
  static const int kTaskReplanFieldNumber = 5;
  inline bool task_replan() const;
  inline void set_task_replan(bool value);
  
  // required string task_flow_nm = 6;
  inline bool has_task_flow_nm() const;
  inline void clear_task_flow_nm();
  static const int kTaskFlowNmFieldNumber = 6;
  inline const ::std::string& task_flow_nm() const;
  inline void set_task_flow_nm(const ::std::string& value);
  inline void set_task_flow_nm(const char* value);
  inline void set_task_flow_nm(const char* value, size_t size);
  inline ::std::string* mutable_task_flow_nm();
  
  // required string task_flow_seq = 7;
  inline bool has_task_flow_seq() const;
  inline void clear_task_flow_seq();
  static const int kTaskFlowSeqFieldNumber = 7;
  inline const ::std::string& task_flow_seq() const;
  inline void set_task_flow_seq(const ::std::string& value);
  inline void set_task_flow_seq(const char* value);
  inline void set_task_flow_seq(const char* value, size_t size);
  inline ::std::string* mutable_task_flow_seq();
  
  // required string action_seq = 8;
  inline bool has_action_seq() const;
  inline void clear_action_seq();
  static const int kActionSeqFieldNumber = 8;
  inline const ::std::string& action_seq() const;
  inline void set_action_seq(const ::std::string& value);
  inline void set_action_seq(const char* value);
  inline void set_action_seq(const char* value, size_t size);
  inline ::std::string* mutable_action_seq();
  
  // required string get_put = 9;
  inline bool has_get_put() const;
  inline void clear_get_put();
  static const int kGetPutFieldNumber = 9;
  inline const ::std::string& get_put() const;
  inline void set_get_put(const ::std::string& value);
  inline void set_get_put(const char* value);
  inline void set_get_put(const char* value, size_t size);
  inline ::std::string* mutable_get_put();
  
  // required string mv_seg = 10;
  inline bool has_mv_seg() const;
  inline void clear_mv_seg();
  static const int kMvSegFieldNumber = 10;
  inline const ::std::string& mv_seg() const;
  inline void set_mv_seg(const ::std::string& value);
  inline void set_mv_seg(const char* value);
  inline void set_mv_seg(const char* value, size_t size);
  inline ::std::string* mutable_mv_seg();
  
  // required string action_type_uuid = 11;
  inline bool has_action_type_uuid() const;
  inline void clear_action_type_uuid();
  static const int kActionTypeUuidFieldNumber = 11;
  inline const ::std::string& action_type_uuid() const;
  inline void set_action_type_uuid(const ::std::string& value);
  inline void set_action_type_uuid(const char* value);
  inline void set_action_type_uuid(const char* value, size_t size);
  inline ::std::string* mutable_action_type_uuid();
  
  // required string node_id = 12;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 12;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  
  // required int32 node_seq = 13;
  inline bool has_node_seq() const;
  inline void clear_node_seq();
  static const int kNodeSeqFieldNumber = 13;
  inline ::google::protobuf::int32 node_seq() const;
  inline void set_node_seq(::google::protobuf::int32 value);
  
  // required float trigger_para = 14;
  inline bool has_trigger_para() const;
  inline void clear_trigger_para();
  static const int kTriggerParaFieldNumber = 14;
  inline float trigger_para() const;
  inline void set_trigger_para(float value);
  
  // required string action_para = 15;
  inline bool has_action_para() const;
  inline void clear_action_para();
  static const int kActionParaFieldNumber = 15;
  inline const ::std::string& action_para() const;
  inline void set_action_para(const ::std::string& value);
  inline void set_action_para(const char* value);
  inline void set_action_para(const char* value, size_t size);
  inline ::std::string* mutable_action_para();
  
  // required string describe = 16;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 16;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  
  // @@protoc_insertion_point(class_scope:KPS.mp_bind_action)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 index_;
  bool enable_;
  bool turn_;
  bool passing_bay_;
  bool task_replan_;
  ::std::string* task_flow_nm_;
  static const ::std::string _default_task_flow_nm_;
  ::std::string* task_flow_seq_;
  static const ::std::string _default_task_flow_seq_;
  ::std::string* action_seq_;
  static const ::std::string _default_action_seq_;
  ::std::string* get_put_;
  static const ::std::string _default_get_put_;
  ::std::string* mv_seg_;
  static const ::std::string _default_mv_seg_;
  ::std::string* action_type_uuid_;
  static const ::std::string _default_action_type_uuid_;
  ::std::string* node_id_;
  static const ::std::string _default_node_id_;
  ::google::protobuf::int32 node_seq_;
  float trigger_para_;
  ::std::string* action_para_;
  static const ::std::string _default_action_para_;
  ::std::string* describe_;
  static const ::std::string _default_describe_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mp_bind_action* default_instance_;
};
// -------------------------------------------------------------------

class mp_bind_io : public ::google::protobuf::Message {
 public:
  mp_bind_io();
  virtual ~mp_bind_io();
  
  mp_bind_io(const mp_bind_io& from);
  
  inline mp_bind_io& operator=(const mp_bind_io& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mp_bind_io& default_instance();
  
  void Swap(mp_bind_io* other);
  
  // implements Message ----------------------------------------------
  
  mp_bind_io* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mp_bind_io& from);
  void MergeFrom(const mp_bind_io& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef mp_bind_io_Bind_IO_Type Bind_IO_Type;
  static const Bind_IO_Type NONE = mp_bind_io_Bind_IO_Type_NONE;
  static const Bind_IO_Type POR_INPUT_PT_PUT = mp_bind_io_Bind_IO_Type_POR_INPUT_PT_PUT;
  static const Bind_IO_Type POR_INPUT_CG_GET = mp_bind_io_Bind_IO_Type_POR_INPUT_CG_GET;
  static const Bind_IO_Type POR_OUTPUT_PT_PUT = mp_bind_io_Bind_IO_Type_POR_OUTPUT_PT_PUT;
  static const Bind_IO_Type POR_OUTPUT_CG_GET = mp_bind_io_Bind_IO_Type_POR_OUTPUT_CG_GET;
  static const Bind_IO_Type CUS_INPUT_CG_PUT = mp_bind_io_Bind_IO_Type_CUS_INPUT_CG_PUT;
  static const Bind_IO_Type CUS_INPUT_PT_GET = mp_bind_io_Bind_IO_Type_CUS_INPUT_PT_GET;
  static const Bind_IO_Type CUS_OUTPUT_CG_PUT = mp_bind_io_Bind_IO_Type_CUS_OUTPUT_CG_PUT;
  static const Bind_IO_Type CUS_OUTPUT_PT_GET = mp_bind_io_Bind_IO_Type_CUS_OUTPUT_PT_GET;
  static const Bind_IO_Type STO_INPUT_EMPTY = mp_bind_io_Bind_IO_Type_STO_INPUT_EMPTY;
  static const Bind_IO_Type STO_OUTPUT_EMPTY = mp_bind_io_Bind_IO_Type_STO_OUTPUT_EMPTY;
  static const Bind_IO_Type CHARGE_INPUT_ONOFF = mp_bind_io_Bind_IO_Type_CHARGE_INPUT_ONOFF;
  static const Bind_IO_Type CHARGE_INPUT_VOLTAGE = mp_bind_io_Bind_IO_Type_CHARGE_INPUT_VOLTAGE;
  static const Bind_IO_Type CHARGE_OUTPUT_ONOFF = mp_bind_io_Bind_IO_Type_CHARGE_OUTPUT_ONOFF;
  static inline bool Bind_IO_Type_IsValid(int value) {
    return mp_bind_io_Bind_IO_Type_IsValid(value);
  }
  static const Bind_IO_Type Bind_IO_Type_MIN =
    mp_bind_io_Bind_IO_Type_Bind_IO_Type_MIN;
  static const Bind_IO_Type Bind_IO_Type_MAX =
    mp_bind_io_Bind_IO_Type_Bind_IO_Type_MAX;
  static const int Bind_IO_Type_ARRAYSIZE =
    mp_bind_io_Bind_IO_Type_Bind_IO_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Bind_IO_Type_descriptor() {
    return mp_bind_io_Bind_IO_Type_descriptor();
  }
  static inline const ::std::string& Bind_IO_Type_Name(Bind_IO_Type value) {
    return mp_bind_io_Bind_IO_Type_Name(value);
  }
  static inline bool Bind_IO_Type_Parse(const ::std::string& name,
      Bind_IO_Type* value) {
    return mp_bind_io_Bind_IO_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);
  
  // required .KPS.mp_bind_io.Bind_IO_Type io_type = 2;
  inline bool has_io_type() const;
  inline void clear_io_type();
  static const int kIoTypeFieldNumber = 2;
  inline ::KPS::mp_bind_io_Bind_IO_Type io_type() const;
  inline void set_io_type(::KPS::mp_bind_io_Bind_IO_Type value);
  
  // required string id_name = 3;
  inline bool has_id_name() const;
  inline void clear_id_name();
  static const int kIdNameFieldNumber = 3;
  inline const ::std::string& id_name() const;
  inline void set_id_name(const ::std::string& value);
  inline void set_id_name(const char* value);
  inline void set_id_name(const char* value, size_t size);
  inline ::std::string* mutable_id_name();
  
  // optional string para = 4;
  inline bool has_para() const;
  inline void clear_para();
  static const int kParaFieldNumber = 4;
  inline const ::std::string& para() const;
  inline void set_para(const ::std::string& value);
  inline void set_para(const char* value);
  inline void set_para(const char* value, size_t size);
  inline ::std::string* mutable_para();
  
  // @@protoc_insertion_point(class_scope:KPS.mp_bind_io)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool enable_;
  int io_type_;
  ::std::string* id_name_;
  static const ::std::string _default_id_name_;
  ::std::string* para_;
  static const ::std::string _default_para_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mp_bind_io* default_instance_;
};
// -------------------------------------------------------------------

class mp_item_base : public ::google::protobuf::Message {
 public:
  mp_item_base();
  virtual ~mp_item_base();
  
  mp_item_base(const mp_item_base& from);
  
  inline mp_item_base& operator=(const mp_item_base& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mp_item_base& default_instance();
  
  void Swap(mp_item_base* other);
  
  // implements Message ----------------------------------------------
  
  mp_item_base* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mp_item_base& from);
  void MergeFrom(const mp_item_base& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required string uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  
  // required string color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  
  // repeated string group = 4;
  inline int group_size() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 4;
  inline const ::std::string& group(int index) const;
  inline ::std::string* mutable_group(int index);
  inline void set_group(int index, const ::std::string& value);
  inline void set_group(int index, const char* value);
  inline void set_group(int index, const char* value, size_t size);
  inline ::std::string* add_group();
  inline void add_group(const ::std::string& value);
  inline void add_group(const char* value);
  inline void add_group(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& group() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_group();
  
  // repeated .KPS.mp_bind_action bind_actions = 5;
  inline int bind_actions_size() const;
  inline void clear_bind_actions();
  static const int kBindActionsFieldNumber = 5;
  inline const ::KPS::mp_bind_action& bind_actions(int index) const;
  inline ::KPS::mp_bind_action* mutable_bind_actions(int index);
  inline ::KPS::mp_bind_action* add_bind_actions();
  inline const ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_action >&
      bind_actions() const;
  inline ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_action >*
      mutable_bind_actions();
  
  // repeated .KPS.mp_bind_io bind_io = 6;
  inline int bind_io_size() const;
  inline void clear_bind_io();
  static const int kBindIoFieldNumber = 6;
  inline const ::KPS::mp_bind_io& bind_io(int index) const;
  inline ::KPS::mp_bind_io* mutable_bind_io(int index);
  inline ::KPS::mp_bind_io* add_bind_io();
  inline const ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_io >&
      bind_io() const;
  inline ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_io >*
      mutable_bind_io();
  
  // required .KPS.mp_pallet_cargo pallet_cargo = 7;
  inline bool has_pallet_cargo() const;
  inline void clear_pallet_cargo();
  static const int kPalletCargoFieldNumber = 7;
  inline const ::KPS::mp_pallet_cargo& pallet_cargo() const;
  inline ::KPS::mp_pallet_cargo* mutable_pallet_cargo();
  
  // required string creation_time = 8;
  inline bool has_creation_time() const;
  inline void clear_creation_time();
  static const int kCreationTimeFieldNumber = 8;
  inline const ::std::string& creation_time() const;
  inline void set_creation_time(const ::std::string& value);
  inline void set_creation_time(const char* value);
  inline void set_creation_time(const char* value, size_t size);
  inline ::std::string* mutable_creation_time();
  
  // optional string destruction_time = 9;
  inline bool has_destruction_time() const;
  inline void clear_destruction_time();
  static const int kDestructionTimeFieldNumber = 9;
  inline const ::std::string& destruction_time() const;
  inline void set_destruction_time(const ::std::string& value);
  inline void set_destruction_time(const char* value);
  inline void set_destruction_time(const char* value, size_t size);
  inline ::std::string* mutable_destruction_time();
  
  // required .KPS.mp_pos_data pos = 10;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 10;
  inline const ::KPS::mp_pos_data& pos() const;
  inline ::KPS::mp_pos_data* mutable_pos();
  
  // repeated string cmd_his = 11;
  inline int cmd_his_size() const;
  inline void clear_cmd_his();
  static const int kCmdHisFieldNumber = 11;
  inline const ::std::string& cmd_his(int index) const;
  inline ::std::string* mutable_cmd_his(int index);
  inline void set_cmd_his(int index, const ::std::string& value);
  inline void set_cmd_his(int index, const char* value);
  inline void set_cmd_his(int index, const char* value, size_t size);
  inline ::std::string* add_cmd_his();
  inline void add_cmd_his(const ::std::string& value);
  inline void add_cmd_his(const char* value);
  inline void add_cmd_his(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cmd_his() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cmd_his();
  
  // optional string describe = 12;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 12;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const char* value, size_t size);
  inline ::std::string* mutable_describe();
  
  // optional string bind_node_id = 13;
  inline bool has_bind_node_id() const;
  inline void clear_bind_node_id();
  static const int kBindNodeIdFieldNumber = 13;
  inline const ::std::string& bind_node_id() const;
  inline void set_bind_node_id(const ::std::string& value);
  inline void set_bind_node_id(const char* value);
  inline void set_bind_node_id(const char* value, size_t size);
  inline ::std::string* mutable_bind_node_id();
  
  // optional float orientation = 14;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 14;
  inline float orientation() const;
  inline void set_orientation(float value);
  
  // optional float ori_rotate = 15;
  inline bool has_ori_rotate() const;
  inline void clear_ori_rotate();
  static const int kOriRotateFieldNumber = 15;
  inline float ori_rotate() const;
  inline void set_ori_rotate(float value);
  
  // optional int32 priority = 16;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 16;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);
  
  // required string pallet_uuid = 17;
  inline bool has_pallet_uuid() const;
  inline void clear_pallet_uuid();
  static const int kPalletUuidFieldNumber = 17;
  inline const ::std::string& pallet_uuid() const;
  inline void set_pallet_uuid(const ::std::string& value);
  inline void set_pallet_uuid(const char* value);
  inline void set_pallet_uuid(const char* value, size_t size);
  inline ::std::string* mutable_pallet_uuid();
  
  // optional uint32 row = 18;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 18;
  inline ::google::protobuf::uint32 row() const;
  inline void set_row(::google::protobuf::uint32 value);
  
  // optional uint32 row_size = 19;
  inline bool has_row_size() const;
  inline void clear_row_size();
  static const int kRowSizeFieldNumber = 19;
  inline ::google::protobuf::uint32 row_size() const;
  inline void set_row_size(::google::protobuf::uint32 value);
  
  // optional uint32 col = 20;
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 20;
  inline ::google::protobuf::uint32 col() const;
  inline void set_col(::google::protobuf::uint32 value);
  
  // optional uint32 col_size = 21;
  inline bool has_col_size() const;
  inline void clear_col_size();
  static const int kColSizeFieldNumber = 21;
  inline ::google::protobuf::uint32 col_size() const;
  inline void set_col_size(::google::protobuf::uint32 value);
  
  // optional uint32 level = 22;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 22;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);
  
  // optional uint32 level_size = 23;
  inline bool has_level_size() const;
  inline void clear_level_size();
  static const int kLevelSizeFieldNumber = 23;
  inline ::google::protobuf::uint32 level_size() const;
  inline void set_level_size(::google::protobuf::uint32 value);
  
  // optional uint32 area = 24;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 24;
  inline ::google::protobuf::uint32 area() const;
  inline void set_area(::google::protobuf::uint32 value);
  
  // optional string para = 25;
  inline bool has_para() const;
  inline void clear_para();
  static const int kParaFieldNumber = 25;
  inline const ::std::string& para() const;
  inline void set_para(const ::std::string& value);
  inline void set_para(const char* value);
  inline void set_para(const char* value, size_t size);
  inline ::std::string* mutable_para();
  
  // @@protoc_insertion_point(class_scope:KPS.mp_item_base)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 id_;
  ::std::string* uuid_;
  static const ::std::string _default_uuid_;
  ::std::string* color_;
  static const ::std::string _default_color_;
  ::google::protobuf::RepeatedPtrField< ::std::string> group_;
  ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_action > bind_actions_;
  ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_io > bind_io_;
  ::KPS::mp_pallet_cargo* pallet_cargo_;
  ::std::string* creation_time_;
  static const ::std::string _default_creation_time_;
  ::std::string* destruction_time_;
  static const ::std::string _default_destruction_time_;
  ::KPS::mp_pos_data* pos_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cmd_his_;
  ::std::string* describe_;
  static const ::std::string _default_describe_;
  ::std::string* bind_node_id_;
  static const ::std::string _default_bind_node_id_;
  float orientation_;
  float ori_rotate_;
  ::google::protobuf::int32 priority_;
  ::std::string* pallet_uuid_;
  static const ::std::string _default_pallet_uuid_;
  ::google::protobuf::uint32 row_;
  ::google::protobuf::uint32 row_size_;
  ::google::protobuf::uint32 col_;
  ::google::protobuf::uint32 col_size_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 level_size_;
  ::google::protobuf::uint32 area_;
  ::std::string* para_;
  static const ::std::string _default_para_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mp_item_base* default_instance_;
};
// ===================================================================


// ===================================================================

// mp_odom_data

// required float x = 1;
inline bool mp_odom_data::has_x() const {
  return _has_bit(0);
}
inline void mp_odom_data::clear_x() {
  x_ = 0;
  _clear_bit(0);
}
inline float mp_odom_data::x() const {
  return x_;
}
inline void mp_odom_data::set_x(float value) {
  _set_bit(0);
  x_ = value;
}

// required float y = 2;
inline bool mp_odom_data::has_y() const {
  return _has_bit(1);
}
inline void mp_odom_data::clear_y() {
  y_ = 0;
  _clear_bit(1);
}
inline float mp_odom_data::y() const {
  return y_;
}
inline void mp_odom_data::set_y(float value) {
  _set_bit(1);
  y_ = value;
}

// required float th = 3;
inline bool mp_odom_data::has_th() const {
  return _has_bit(2);
}
inline void mp_odom_data::clear_th() {
  th_ = 0;
  _clear_bit(2);
}
inline float mp_odom_data::th() const {
  return th_;
}
inline void mp_odom_data::set_th(float value) {
  _set_bit(2);
  th_ = value;
}

// required float vx = 4;
inline bool mp_odom_data::has_vx() const {
  return _has_bit(3);
}
inline void mp_odom_data::clear_vx() {
  vx_ = 0;
  _clear_bit(3);
}
inline float mp_odom_data::vx() const {
  return vx_;
}
inline void mp_odom_data::set_vx(float value) {
  _set_bit(3);
  vx_ = value;
}

// required float vy = 5;
inline bool mp_odom_data::has_vy() const {
  return _has_bit(4);
}
inline void mp_odom_data::clear_vy() {
  vy_ = 0;
  _clear_bit(4);
}
inline float mp_odom_data::vy() const {
  return vy_;
}
inline void mp_odom_data::set_vy(float value) {
  _set_bit(4);
  vy_ = value;
}

// required float vw = 6;
inline bool mp_odom_data::has_vw() const {
  return _has_bit(5);
}
inline void mp_odom_data::clear_vw() {
  vw_ = 0;
  _clear_bit(5);
}
inline float mp_odom_data::vw() const {
  return vw_;
}
inline void mp_odom_data::set_vw(float value) {
  _set_bit(5);
  vw_ = value;
}

// -------------------------------------------------------------------

// mp_pos_data

// required float x = 1;
inline bool mp_pos_data::has_x() const {
  return _has_bit(0);
}
inline void mp_pos_data::clear_x() {
  x_ = 0;
  _clear_bit(0);
}
inline float mp_pos_data::x() const {
  return x_;
}
inline void mp_pos_data::set_x(float value) {
  _set_bit(0);
  x_ = value;
}

// required float y = 2;
inline bool mp_pos_data::has_y() const {
  return _has_bit(1);
}
inline void mp_pos_data::clear_y() {
  y_ = 0;
  _clear_bit(1);
}
inline float mp_pos_data::y() const {
  return y_;
}
inline void mp_pos_data::set_y(float value) {
  _set_bit(1);
  y_ = value;
}

// required float th = 3;
inline bool mp_pos_data::has_th() const {
  return _has_bit(2);
}
inline void mp_pos_data::clear_th() {
  th_ = 0;
  _clear_bit(2);
}
inline float mp_pos_data::th() const {
  return th_;
}
inline void mp_pos_data::set_th(float value) {
  _set_bit(2);
  th_ = value;
}

// -------------------------------------------------------------------

// mp_vec_data

// required float x = 1;
inline bool mp_vec_data::has_x() const {
  return _has_bit(0);
}
inline void mp_vec_data::clear_x() {
  x_ = 0;
  _clear_bit(0);
}
inline float mp_vec_data::x() const {
  return x_;
}
inline void mp_vec_data::set_x(float value) {
  _set_bit(0);
  x_ = value;
}

// required float y = 2;
inline bool mp_vec_data::has_y() const {
  return _has_bit(1);
}
inline void mp_vec_data::clear_y() {
  y_ = 0;
  _clear_bit(1);
}
inline float mp_vec_data::y() const {
  return y_;
}
inline void mp_vec_data::set_y(float value) {
  _set_bit(1);
  y_ = value;
}

// -------------------------------------------------------------------

// mp_schedule

// required bool enable = 1;
inline bool mp_schedule::has_enable() const {
  return _has_bit(0);
}
inline void mp_schedule::clear_enable() {
  enable_ = false;
  _clear_bit(0);
}
inline bool mp_schedule::enable() const {
  return enable_;
}
inline void mp_schedule::set_enable(bool value) {
  _set_bit(0);
  enable_ = value;
}

// required string sch_date = 2;
inline bool mp_schedule::has_sch_date() const {
  return _has_bit(1);
}
inline void mp_schedule::clear_sch_date() {
  if (sch_date_ != &_default_sch_date_) {
    sch_date_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& mp_schedule::sch_date() const {
  return *sch_date_;
}
inline void mp_schedule::set_sch_date(const ::std::string& value) {
  _set_bit(1);
  if (sch_date_ == &_default_sch_date_) {
    sch_date_ = new ::std::string;
  }
  sch_date_->assign(value);
}
inline void mp_schedule::set_sch_date(const char* value) {
  _set_bit(1);
  if (sch_date_ == &_default_sch_date_) {
    sch_date_ = new ::std::string;
  }
  sch_date_->assign(value);
}
inline void mp_schedule::set_sch_date(const char* value, size_t size) {
  _set_bit(1);
  if (sch_date_ == &_default_sch_date_) {
    sch_date_ = new ::std::string;
  }
  sch_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_schedule::mutable_sch_date() {
  _set_bit(1);
  if (sch_date_ == &_default_sch_date_) {
    sch_date_ = new ::std::string;
  }
  return sch_date_;
}

// required .KPS.mp_pallet_cargo pallet_cargo = 3;
inline bool mp_schedule::has_pallet_cargo() const {
  return _has_bit(2);
}
inline void mp_schedule::clear_pallet_cargo() {
  if (pallet_cargo_ != NULL) pallet_cargo_->::KPS::mp_pallet_cargo::Clear();
  _clear_bit(2);
}
inline const ::KPS::mp_pallet_cargo& mp_schedule::pallet_cargo() const {
  return pallet_cargo_ != NULL ? *pallet_cargo_ : *default_instance_->pallet_cargo_;
}
inline ::KPS::mp_pallet_cargo* mp_schedule::mutable_pallet_cargo() {
  _set_bit(2);
  if (pallet_cargo_ == NULL) pallet_cargo_ = new ::KPS::mp_pallet_cargo;
  return pallet_cargo_;
}

// -------------------------------------------------------------------

// mp_bind_action

// required uint32 index = 1;
inline bool mp_bind_action::has_index() const {
  return _has_bit(0);
}
inline void mp_bind_action::clear_index() {
  index_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 mp_bind_action::index() const {
  return index_;
}
inline void mp_bind_action::set_index(::google::protobuf::uint32 value) {
  _set_bit(0);
  index_ = value;
}

// required bool enable = 2;
inline bool mp_bind_action::has_enable() const {
  return _has_bit(1);
}
inline void mp_bind_action::clear_enable() {
  enable_ = false;
  _clear_bit(1);
}
inline bool mp_bind_action::enable() const {
  return enable_;
}
inline void mp_bind_action::set_enable(bool value) {
  _set_bit(1);
  enable_ = value;
}

// required bool turn = 3;
inline bool mp_bind_action::has_turn() const {
  return _has_bit(2);
}
inline void mp_bind_action::clear_turn() {
  turn_ = false;
  _clear_bit(2);
}
inline bool mp_bind_action::turn() const {
  return turn_;
}
inline void mp_bind_action::set_turn(bool value) {
  _set_bit(2);
  turn_ = value;
}

// required bool passing_bay = 4;
inline bool mp_bind_action::has_passing_bay() const {
  return _has_bit(3);
}
inline void mp_bind_action::clear_passing_bay() {
  passing_bay_ = false;
  _clear_bit(3);
}
inline bool mp_bind_action::passing_bay() const {
  return passing_bay_;
}
inline void mp_bind_action::set_passing_bay(bool value) {
  _set_bit(3);
  passing_bay_ = value;
}

// required bool task_replan = 5;
inline bool mp_bind_action::has_task_replan() const {
  return _has_bit(4);
}
inline void mp_bind_action::clear_task_replan() {
  task_replan_ = false;
  _clear_bit(4);
}
inline bool mp_bind_action::task_replan() const {
  return task_replan_;
}
inline void mp_bind_action::set_task_replan(bool value) {
  _set_bit(4);
  task_replan_ = value;
}

// required string task_flow_nm = 6;
inline bool mp_bind_action::has_task_flow_nm() const {
  return _has_bit(5);
}
inline void mp_bind_action::clear_task_flow_nm() {
  if (task_flow_nm_ != &_default_task_flow_nm_) {
    task_flow_nm_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& mp_bind_action::task_flow_nm() const {
  return *task_flow_nm_;
}
inline void mp_bind_action::set_task_flow_nm(const ::std::string& value) {
  _set_bit(5);
  if (task_flow_nm_ == &_default_task_flow_nm_) {
    task_flow_nm_ = new ::std::string;
  }
  task_flow_nm_->assign(value);
}
inline void mp_bind_action::set_task_flow_nm(const char* value) {
  _set_bit(5);
  if (task_flow_nm_ == &_default_task_flow_nm_) {
    task_flow_nm_ = new ::std::string;
  }
  task_flow_nm_->assign(value);
}
inline void mp_bind_action::set_task_flow_nm(const char* value, size_t size) {
  _set_bit(5);
  if (task_flow_nm_ == &_default_task_flow_nm_) {
    task_flow_nm_ = new ::std::string;
  }
  task_flow_nm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_action::mutable_task_flow_nm() {
  _set_bit(5);
  if (task_flow_nm_ == &_default_task_flow_nm_) {
    task_flow_nm_ = new ::std::string;
  }
  return task_flow_nm_;
}

// required string task_flow_seq = 7;
inline bool mp_bind_action::has_task_flow_seq() const {
  return _has_bit(6);
}
inline void mp_bind_action::clear_task_flow_seq() {
  if (task_flow_seq_ != &_default_task_flow_seq_) {
    task_flow_seq_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& mp_bind_action::task_flow_seq() const {
  return *task_flow_seq_;
}
inline void mp_bind_action::set_task_flow_seq(const ::std::string& value) {
  _set_bit(6);
  if (task_flow_seq_ == &_default_task_flow_seq_) {
    task_flow_seq_ = new ::std::string;
  }
  task_flow_seq_->assign(value);
}
inline void mp_bind_action::set_task_flow_seq(const char* value) {
  _set_bit(6);
  if (task_flow_seq_ == &_default_task_flow_seq_) {
    task_flow_seq_ = new ::std::string;
  }
  task_flow_seq_->assign(value);
}
inline void mp_bind_action::set_task_flow_seq(const char* value, size_t size) {
  _set_bit(6);
  if (task_flow_seq_ == &_default_task_flow_seq_) {
    task_flow_seq_ = new ::std::string;
  }
  task_flow_seq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_action::mutable_task_flow_seq() {
  _set_bit(6);
  if (task_flow_seq_ == &_default_task_flow_seq_) {
    task_flow_seq_ = new ::std::string;
  }
  return task_flow_seq_;
}

// required string action_seq = 8;
inline bool mp_bind_action::has_action_seq() const {
  return _has_bit(7);
}
inline void mp_bind_action::clear_action_seq() {
  if (action_seq_ != &_default_action_seq_) {
    action_seq_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& mp_bind_action::action_seq() const {
  return *action_seq_;
}
inline void mp_bind_action::set_action_seq(const ::std::string& value) {
  _set_bit(7);
  if (action_seq_ == &_default_action_seq_) {
    action_seq_ = new ::std::string;
  }
  action_seq_->assign(value);
}
inline void mp_bind_action::set_action_seq(const char* value) {
  _set_bit(7);
  if (action_seq_ == &_default_action_seq_) {
    action_seq_ = new ::std::string;
  }
  action_seq_->assign(value);
}
inline void mp_bind_action::set_action_seq(const char* value, size_t size) {
  _set_bit(7);
  if (action_seq_ == &_default_action_seq_) {
    action_seq_ = new ::std::string;
  }
  action_seq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_action::mutable_action_seq() {
  _set_bit(7);
  if (action_seq_ == &_default_action_seq_) {
    action_seq_ = new ::std::string;
  }
  return action_seq_;
}

// required string get_put = 9;
inline bool mp_bind_action::has_get_put() const {
  return _has_bit(8);
}
inline void mp_bind_action::clear_get_put() {
  if (get_put_ != &_default_get_put_) {
    get_put_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& mp_bind_action::get_put() const {
  return *get_put_;
}
inline void mp_bind_action::set_get_put(const ::std::string& value) {
  _set_bit(8);
  if (get_put_ == &_default_get_put_) {
    get_put_ = new ::std::string;
  }
  get_put_->assign(value);
}
inline void mp_bind_action::set_get_put(const char* value) {
  _set_bit(8);
  if (get_put_ == &_default_get_put_) {
    get_put_ = new ::std::string;
  }
  get_put_->assign(value);
}
inline void mp_bind_action::set_get_put(const char* value, size_t size) {
  _set_bit(8);
  if (get_put_ == &_default_get_put_) {
    get_put_ = new ::std::string;
  }
  get_put_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_action::mutable_get_put() {
  _set_bit(8);
  if (get_put_ == &_default_get_put_) {
    get_put_ = new ::std::string;
  }
  return get_put_;
}

// required string mv_seg = 10;
inline bool mp_bind_action::has_mv_seg() const {
  return _has_bit(9);
}
inline void mp_bind_action::clear_mv_seg() {
  if (mv_seg_ != &_default_mv_seg_) {
    mv_seg_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& mp_bind_action::mv_seg() const {
  return *mv_seg_;
}
inline void mp_bind_action::set_mv_seg(const ::std::string& value) {
  _set_bit(9);
  if (mv_seg_ == &_default_mv_seg_) {
    mv_seg_ = new ::std::string;
  }
  mv_seg_->assign(value);
}
inline void mp_bind_action::set_mv_seg(const char* value) {
  _set_bit(9);
  if (mv_seg_ == &_default_mv_seg_) {
    mv_seg_ = new ::std::string;
  }
  mv_seg_->assign(value);
}
inline void mp_bind_action::set_mv_seg(const char* value, size_t size) {
  _set_bit(9);
  if (mv_seg_ == &_default_mv_seg_) {
    mv_seg_ = new ::std::string;
  }
  mv_seg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_action::mutable_mv_seg() {
  _set_bit(9);
  if (mv_seg_ == &_default_mv_seg_) {
    mv_seg_ = new ::std::string;
  }
  return mv_seg_;
}

// required string action_type_uuid = 11;
inline bool mp_bind_action::has_action_type_uuid() const {
  return _has_bit(10);
}
inline void mp_bind_action::clear_action_type_uuid() {
  if (action_type_uuid_ != &_default_action_type_uuid_) {
    action_type_uuid_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& mp_bind_action::action_type_uuid() const {
  return *action_type_uuid_;
}
inline void mp_bind_action::set_action_type_uuid(const ::std::string& value) {
  _set_bit(10);
  if (action_type_uuid_ == &_default_action_type_uuid_) {
    action_type_uuid_ = new ::std::string;
  }
  action_type_uuid_->assign(value);
}
inline void mp_bind_action::set_action_type_uuid(const char* value) {
  _set_bit(10);
  if (action_type_uuid_ == &_default_action_type_uuid_) {
    action_type_uuid_ = new ::std::string;
  }
  action_type_uuid_->assign(value);
}
inline void mp_bind_action::set_action_type_uuid(const char* value, size_t size) {
  _set_bit(10);
  if (action_type_uuid_ == &_default_action_type_uuid_) {
    action_type_uuid_ = new ::std::string;
  }
  action_type_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_action::mutable_action_type_uuid() {
  _set_bit(10);
  if (action_type_uuid_ == &_default_action_type_uuid_) {
    action_type_uuid_ = new ::std::string;
  }
  return action_type_uuid_;
}

// required string node_id = 12;
inline bool mp_bind_action::has_node_id() const {
  return _has_bit(11);
}
inline void mp_bind_action::clear_node_id() {
  if (node_id_ != &_default_node_id_) {
    node_id_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& mp_bind_action::node_id() const {
  return *node_id_;
}
inline void mp_bind_action::set_node_id(const ::std::string& value) {
  _set_bit(11);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void mp_bind_action::set_node_id(const char* value) {
  _set_bit(11);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void mp_bind_action::set_node_id(const char* value, size_t size) {
  _set_bit(11);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_action::mutable_node_id() {
  _set_bit(11);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}

// required int32 node_seq = 13;
inline bool mp_bind_action::has_node_seq() const {
  return _has_bit(12);
}
inline void mp_bind_action::clear_node_seq() {
  node_seq_ = 0;
  _clear_bit(12);
}
inline ::google::protobuf::int32 mp_bind_action::node_seq() const {
  return node_seq_;
}
inline void mp_bind_action::set_node_seq(::google::protobuf::int32 value) {
  _set_bit(12);
  node_seq_ = value;
}

// required float trigger_para = 14;
inline bool mp_bind_action::has_trigger_para() const {
  return _has_bit(13);
}
inline void mp_bind_action::clear_trigger_para() {
  trigger_para_ = 0;
  _clear_bit(13);
}
inline float mp_bind_action::trigger_para() const {
  return trigger_para_;
}
inline void mp_bind_action::set_trigger_para(float value) {
  _set_bit(13);
  trigger_para_ = value;
}

// required string action_para = 15;
inline bool mp_bind_action::has_action_para() const {
  return _has_bit(14);
}
inline void mp_bind_action::clear_action_para() {
  if (action_para_ != &_default_action_para_) {
    action_para_->clear();
  }
  _clear_bit(14);
}
inline const ::std::string& mp_bind_action::action_para() const {
  return *action_para_;
}
inline void mp_bind_action::set_action_para(const ::std::string& value) {
  _set_bit(14);
  if (action_para_ == &_default_action_para_) {
    action_para_ = new ::std::string;
  }
  action_para_->assign(value);
}
inline void mp_bind_action::set_action_para(const char* value) {
  _set_bit(14);
  if (action_para_ == &_default_action_para_) {
    action_para_ = new ::std::string;
  }
  action_para_->assign(value);
}
inline void mp_bind_action::set_action_para(const char* value, size_t size) {
  _set_bit(14);
  if (action_para_ == &_default_action_para_) {
    action_para_ = new ::std::string;
  }
  action_para_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_action::mutable_action_para() {
  _set_bit(14);
  if (action_para_ == &_default_action_para_) {
    action_para_ = new ::std::string;
  }
  return action_para_;
}

// required string describe = 16;
inline bool mp_bind_action::has_describe() const {
  return _has_bit(15);
}
inline void mp_bind_action::clear_describe() {
  if (describe_ != &_default_describe_) {
    describe_->clear();
  }
  _clear_bit(15);
}
inline const ::std::string& mp_bind_action::describe() const {
  return *describe_;
}
inline void mp_bind_action::set_describe(const ::std::string& value) {
  _set_bit(15);
  if (describe_ == &_default_describe_) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void mp_bind_action::set_describe(const char* value) {
  _set_bit(15);
  if (describe_ == &_default_describe_) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void mp_bind_action::set_describe(const char* value, size_t size) {
  _set_bit(15);
  if (describe_ == &_default_describe_) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_action::mutable_describe() {
  _set_bit(15);
  if (describe_ == &_default_describe_) {
    describe_ = new ::std::string;
  }
  return describe_;
}

// -------------------------------------------------------------------

// mp_bind_io

// required bool enable = 1;
inline bool mp_bind_io::has_enable() const {
  return _has_bit(0);
}
inline void mp_bind_io::clear_enable() {
  enable_ = false;
  _clear_bit(0);
}
inline bool mp_bind_io::enable() const {
  return enable_;
}
inline void mp_bind_io::set_enable(bool value) {
  _set_bit(0);
  enable_ = value;
}

// required .KPS.mp_bind_io.Bind_IO_Type io_type = 2;
inline bool mp_bind_io::has_io_type() const {
  return _has_bit(1);
}
inline void mp_bind_io::clear_io_type() {
  io_type_ = 0;
  _clear_bit(1);
}
inline ::KPS::mp_bind_io_Bind_IO_Type mp_bind_io::io_type() const {
  return static_cast< ::KPS::mp_bind_io_Bind_IO_Type >(io_type_);
}
inline void mp_bind_io::set_io_type(::KPS::mp_bind_io_Bind_IO_Type value) {
  GOOGLE_DCHECK(::KPS::mp_bind_io_Bind_IO_Type_IsValid(value));
  _set_bit(1);
  io_type_ = value;
}

// required string id_name = 3;
inline bool mp_bind_io::has_id_name() const {
  return _has_bit(2);
}
inline void mp_bind_io::clear_id_name() {
  if (id_name_ != &_default_id_name_) {
    id_name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& mp_bind_io::id_name() const {
  return *id_name_;
}
inline void mp_bind_io::set_id_name(const ::std::string& value) {
  _set_bit(2);
  if (id_name_ == &_default_id_name_) {
    id_name_ = new ::std::string;
  }
  id_name_->assign(value);
}
inline void mp_bind_io::set_id_name(const char* value) {
  _set_bit(2);
  if (id_name_ == &_default_id_name_) {
    id_name_ = new ::std::string;
  }
  id_name_->assign(value);
}
inline void mp_bind_io::set_id_name(const char* value, size_t size) {
  _set_bit(2);
  if (id_name_ == &_default_id_name_) {
    id_name_ = new ::std::string;
  }
  id_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_io::mutable_id_name() {
  _set_bit(2);
  if (id_name_ == &_default_id_name_) {
    id_name_ = new ::std::string;
  }
  return id_name_;
}

// optional string para = 4;
inline bool mp_bind_io::has_para() const {
  return _has_bit(3);
}
inline void mp_bind_io::clear_para() {
  if (para_ != &_default_para_) {
    para_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& mp_bind_io::para() const {
  return *para_;
}
inline void mp_bind_io::set_para(const ::std::string& value) {
  _set_bit(3);
  if (para_ == &_default_para_) {
    para_ = new ::std::string;
  }
  para_->assign(value);
}
inline void mp_bind_io::set_para(const char* value) {
  _set_bit(3);
  if (para_ == &_default_para_) {
    para_ = new ::std::string;
  }
  para_->assign(value);
}
inline void mp_bind_io::set_para(const char* value, size_t size) {
  _set_bit(3);
  if (para_ == &_default_para_) {
    para_ = new ::std::string;
  }
  para_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_bind_io::mutable_para() {
  _set_bit(3);
  if (para_ == &_default_para_) {
    para_ = new ::std::string;
  }
  return para_;
}

// -------------------------------------------------------------------

// mp_item_base

// required uint32 id = 1;
inline bool mp_item_base::has_id() const {
  return _has_bit(0);
}
inline void mp_item_base::clear_id() {
  id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 mp_item_base::id() const {
  return id_;
}
inline void mp_item_base::set_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  id_ = value;
}

// required string uuid = 2;
inline bool mp_item_base::has_uuid() const {
  return _has_bit(1);
}
inline void mp_item_base::clear_uuid() {
  if (uuid_ != &_default_uuid_) {
    uuid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& mp_item_base::uuid() const {
  return *uuid_;
}
inline void mp_item_base::set_uuid(const ::std::string& value) {
  _set_bit(1);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void mp_item_base::set_uuid(const char* value) {
  _set_bit(1);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void mp_item_base::set_uuid(const char* value, size_t size) {
  _set_bit(1);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::mutable_uuid() {
  _set_bit(1);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}

// required string color = 3;
inline bool mp_item_base::has_color() const {
  return _has_bit(2);
}
inline void mp_item_base::clear_color() {
  if (color_ != &_default_color_) {
    color_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& mp_item_base::color() const {
  return *color_;
}
inline void mp_item_base::set_color(const ::std::string& value) {
  _set_bit(2);
  if (color_ == &_default_color_) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void mp_item_base::set_color(const char* value) {
  _set_bit(2);
  if (color_ == &_default_color_) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void mp_item_base::set_color(const char* value, size_t size) {
  _set_bit(2);
  if (color_ == &_default_color_) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::mutable_color() {
  _set_bit(2);
  if (color_ == &_default_color_) {
    color_ = new ::std::string;
  }
  return color_;
}

// repeated string group = 4;
inline int mp_item_base::group_size() const {
  return group_.size();
}
inline void mp_item_base::clear_group() {
  group_.Clear();
}
inline const ::std::string& mp_item_base::group(int index) const {
  return group_.Get(index);
}
inline ::std::string* mp_item_base::mutable_group(int index) {
  return group_.Mutable(index);
}
inline void mp_item_base::set_group(int index, const ::std::string& value) {
  group_.Mutable(index)->assign(value);
}
inline void mp_item_base::set_group(int index, const char* value) {
  group_.Mutable(index)->assign(value);
}
inline void mp_item_base::set_group(int index, const char* value, size_t size) {
  group_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::add_group() {
  return group_.Add();
}
inline void mp_item_base::add_group(const ::std::string& value) {
  group_.Add()->assign(value);
}
inline void mp_item_base::add_group(const char* value) {
  group_.Add()->assign(value);
}
inline void mp_item_base::add_group(const char* value, size_t size) {
  group_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
mp_item_base::group() const {
  return group_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
mp_item_base::mutable_group() {
  return &group_;
}

// repeated .KPS.mp_bind_action bind_actions = 5;
inline int mp_item_base::bind_actions_size() const {
  return bind_actions_.size();
}
inline void mp_item_base::clear_bind_actions() {
  bind_actions_.Clear();
}
inline const ::KPS::mp_bind_action& mp_item_base::bind_actions(int index) const {
  return bind_actions_.Get(index);
}
inline ::KPS::mp_bind_action* mp_item_base::mutable_bind_actions(int index) {
  return bind_actions_.Mutable(index);
}
inline ::KPS::mp_bind_action* mp_item_base::add_bind_actions() {
  return bind_actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_action >&
mp_item_base::bind_actions() const {
  return bind_actions_;
}
inline ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_action >*
mp_item_base::mutable_bind_actions() {
  return &bind_actions_;
}

// repeated .KPS.mp_bind_io bind_io = 6;
inline int mp_item_base::bind_io_size() const {
  return bind_io_.size();
}
inline void mp_item_base::clear_bind_io() {
  bind_io_.Clear();
}
inline const ::KPS::mp_bind_io& mp_item_base::bind_io(int index) const {
  return bind_io_.Get(index);
}
inline ::KPS::mp_bind_io* mp_item_base::mutable_bind_io(int index) {
  return bind_io_.Mutable(index);
}
inline ::KPS::mp_bind_io* mp_item_base::add_bind_io() {
  return bind_io_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_io >&
mp_item_base::bind_io() const {
  return bind_io_;
}
inline ::google::protobuf::RepeatedPtrField< ::KPS::mp_bind_io >*
mp_item_base::mutable_bind_io() {
  return &bind_io_;
}

// required .KPS.mp_pallet_cargo pallet_cargo = 7;
inline bool mp_item_base::has_pallet_cargo() const {
  return _has_bit(6);
}
inline void mp_item_base::clear_pallet_cargo() {
  if (pallet_cargo_ != NULL) pallet_cargo_->::KPS::mp_pallet_cargo::Clear();
  _clear_bit(6);
}
inline const ::KPS::mp_pallet_cargo& mp_item_base::pallet_cargo() const {
  return pallet_cargo_ != NULL ? *pallet_cargo_ : *default_instance_->pallet_cargo_;
}
inline ::KPS::mp_pallet_cargo* mp_item_base::mutable_pallet_cargo() {
  _set_bit(6);
  if (pallet_cargo_ == NULL) pallet_cargo_ = new ::KPS::mp_pallet_cargo;
  return pallet_cargo_;
}

// required string creation_time = 8;
inline bool mp_item_base::has_creation_time() const {
  return _has_bit(7);
}
inline void mp_item_base::clear_creation_time() {
  if (creation_time_ != &_default_creation_time_) {
    creation_time_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& mp_item_base::creation_time() const {
  return *creation_time_;
}
inline void mp_item_base::set_creation_time(const ::std::string& value) {
  _set_bit(7);
  if (creation_time_ == &_default_creation_time_) {
    creation_time_ = new ::std::string;
  }
  creation_time_->assign(value);
}
inline void mp_item_base::set_creation_time(const char* value) {
  _set_bit(7);
  if (creation_time_ == &_default_creation_time_) {
    creation_time_ = new ::std::string;
  }
  creation_time_->assign(value);
}
inline void mp_item_base::set_creation_time(const char* value, size_t size) {
  _set_bit(7);
  if (creation_time_ == &_default_creation_time_) {
    creation_time_ = new ::std::string;
  }
  creation_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::mutable_creation_time() {
  _set_bit(7);
  if (creation_time_ == &_default_creation_time_) {
    creation_time_ = new ::std::string;
  }
  return creation_time_;
}

// optional string destruction_time = 9;
inline bool mp_item_base::has_destruction_time() const {
  return _has_bit(8);
}
inline void mp_item_base::clear_destruction_time() {
  if (destruction_time_ != &_default_destruction_time_) {
    destruction_time_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& mp_item_base::destruction_time() const {
  return *destruction_time_;
}
inline void mp_item_base::set_destruction_time(const ::std::string& value) {
  _set_bit(8);
  if (destruction_time_ == &_default_destruction_time_) {
    destruction_time_ = new ::std::string;
  }
  destruction_time_->assign(value);
}
inline void mp_item_base::set_destruction_time(const char* value) {
  _set_bit(8);
  if (destruction_time_ == &_default_destruction_time_) {
    destruction_time_ = new ::std::string;
  }
  destruction_time_->assign(value);
}
inline void mp_item_base::set_destruction_time(const char* value, size_t size) {
  _set_bit(8);
  if (destruction_time_ == &_default_destruction_time_) {
    destruction_time_ = new ::std::string;
  }
  destruction_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::mutable_destruction_time() {
  _set_bit(8);
  if (destruction_time_ == &_default_destruction_time_) {
    destruction_time_ = new ::std::string;
  }
  return destruction_time_;
}

// required .KPS.mp_pos_data pos = 10;
inline bool mp_item_base::has_pos() const {
  return _has_bit(9);
}
inline void mp_item_base::clear_pos() {
  if (pos_ != NULL) pos_->::KPS::mp_pos_data::Clear();
  _clear_bit(9);
}
inline const ::KPS::mp_pos_data& mp_item_base::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::KPS::mp_pos_data* mp_item_base::mutable_pos() {
  _set_bit(9);
  if (pos_ == NULL) pos_ = new ::KPS::mp_pos_data;
  return pos_;
}

// repeated string cmd_his = 11;
inline int mp_item_base::cmd_his_size() const {
  return cmd_his_.size();
}
inline void mp_item_base::clear_cmd_his() {
  cmd_his_.Clear();
}
inline const ::std::string& mp_item_base::cmd_his(int index) const {
  return cmd_his_.Get(index);
}
inline ::std::string* mp_item_base::mutable_cmd_his(int index) {
  return cmd_his_.Mutable(index);
}
inline void mp_item_base::set_cmd_his(int index, const ::std::string& value) {
  cmd_his_.Mutable(index)->assign(value);
}
inline void mp_item_base::set_cmd_his(int index, const char* value) {
  cmd_his_.Mutable(index)->assign(value);
}
inline void mp_item_base::set_cmd_his(int index, const char* value, size_t size) {
  cmd_his_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::add_cmd_his() {
  return cmd_his_.Add();
}
inline void mp_item_base::add_cmd_his(const ::std::string& value) {
  cmd_his_.Add()->assign(value);
}
inline void mp_item_base::add_cmd_his(const char* value) {
  cmd_his_.Add()->assign(value);
}
inline void mp_item_base::add_cmd_his(const char* value, size_t size) {
  cmd_his_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
mp_item_base::cmd_his() const {
  return cmd_his_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
mp_item_base::mutable_cmd_his() {
  return &cmd_his_;
}

// optional string describe = 12;
inline bool mp_item_base::has_describe() const {
  return _has_bit(11);
}
inline void mp_item_base::clear_describe() {
  if (describe_ != &_default_describe_) {
    describe_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& mp_item_base::describe() const {
  return *describe_;
}
inline void mp_item_base::set_describe(const ::std::string& value) {
  _set_bit(11);
  if (describe_ == &_default_describe_) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void mp_item_base::set_describe(const char* value) {
  _set_bit(11);
  if (describe_ == &_default_describe_) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void mp_item_base::set_describe(const char* value, size_t size) {
  _set_bit(11);
  if (describe_ == &_default_describe_) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::mutable_describe() {
  _set_bit(11);
  if (describe_ == &_default_describe_) {
    describe_ = new ::std::string;
  }
  return describe_;
}

// optional string bind_node_id = 13;
inline bool mp_item_base::has_bind_node_id() const {
  return _has_bit(12);
}
inline void mp_item_base::clear_bind_node_id() {
  if (bind_node_id_ != &_default_bind_node_id_) {
    bind_node_id_->clear();
  }
  _clear_bit(12);
}
inline const ::std::string& mp_item_base::bind_node_id() const {
  return *bind_node_id_;
}
inline void mp_item_base::set_bind_node_id(const ::std::string& value) {
  _set_bit(12);
  if (bind_node_id_ == &_default_bind_node_id_) {
    bind_node_id_ = new ::std::string;
  }
  bind_node_id_->assign(value);
}
inline void mp_item_base::set_bind_node_id(const char* value) {
  _set_bit(12);
  if (bind_node_id_ == &_default_bind_node_id_) {
    bind_node_id_ = new ::std::string;
  }
  bind_node_id_->assign(value);
}
inline void mp_item_base::set_bind_node_id(const char* value, size_t size) {
  _set_bit(12);
  if (bind_node_id_ == &_default_bind_node_id_) {
    bind_node_id_ = new ::std::string;
  }
  bind_node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::mutable_bind_node_id() {
  _set_bit(12);
  if (bind_node_id_ == &_default_bind_node_id_) {
    bind_node_id_ = new ::std::string;
  }
  return bind_node_id_;
}

// optional float orientation = 14;
inline bool mp_item_base::has_orientation() const {
  return _has_bit(13);
}
inline void mp_item_base::clear_orientation() {
  orientation_ = 0;
  _clear_bit(13);
}
inline float mp_item_base::orientation() const {
  return orientation_;
}
inline void mp_item_base::set_orientation(float value) {
  _set_bit(13);
  orientation_ = value;
}

// optional float ori_rotate = 15;
inline bool mp_item_base::has_ori_rotate() const {
  return _has_bit(14);
}
inline void mp_item_base::clear_ori_rotate() {
  ori_rotate_ = 0;
  _clear_bit(14);
}
inline float mp_item_base::ori_rotate() const {
  return ori_rotate_;
}
inline void mp_item_base::set_ori_rotate(float value) {
  _set_bit(14);
  ori_rotate_ = value;
}

// optional int32 priority = 16;
inline bool mp_item_base::has_priority() const {
  return _has_bit(15);
}
inline void mp_item_base::clear_priority() {
  priority_ = 0;
  _clear_bit(15);
}
inline ::google::protobuf::int32 mp_item_base::priority() const {
  return priority_;
}
inline void mp_item_base::set_priority(::google::protobuf::int32 value) {
  _set_bit(15);
  priority_ = value;
}

// required string pallet_uuid = 17;
inline bool mp_item_base::has_pallet_uuid() const {
  return _has_bit(16);
}
inline void mp_item_base::clear_pallet_uuid() {
  if (pallet_uuid_ != &_default_pallet_uuid_) {
    pallet_uuid_->clear();
  }
  _clear_bit(16);
}
inline const ::std::string& mp_item_base::pallet_uuid() const {
  return *pallet_uuid_;
}
inline void mp_item_base::set_pallet_uuid(const ::std::string& value) {
  _set_bit(16);
  if (pallet_uuid_ == &_default_pallet_uuid_) {
    pallet_uuid_ = new ::std::string;
  }
  pallet_uuid_->assign(value);
}
inline void mp_item_base::set_pallet_uuid(const char* value) {
  _set_bit(16);
  if (pallet_uuid_ == &_default_pallet_uuid_) {
    pallet_uuid_ = new ::std::string;
  }
  pallet_uuid_->assign(value);
}
inline void mp_item_base::set_pallet_uuid(const char* value, size_t size) {
  _set_bit(16);
  if (pallet_uuid_ == &_default_pallet_uuid_) {
    pallet_uuid_ = new ::std::string;
  }
  pallet_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::mutable_pallet_uuid() {
  _set_bit(16);
  if (pallet_uuid_ == &_default_pallet_uuid_) {
    pallet_uuid_ = new ::std::string;
  }
  return pallet_uuid_;
}

// optional uint32 row = 18;
inline bool mp_item_base::has_row() const {
  return _has_bit(17);
}
inline void mp_item_base::clear_row() {
  row_ = 0u;
  _clear_bit(17);
}
inline ::google::protobuf::uint32 mp_item_base::row() const {
  return row_;
}
inline void mp_item_base::set_row(::google::protobuf::uint32 value) {
  _set_bit(17);
  row_ = value;
}

// optional uint32 row_size = 19;
inline bool mp_item_base::has_row_size() const {
  return _has_bit(18);
}
inline void mp_item_base::clear_row_size() {
  row_size_ = 0u;
  _clear_bit(18);
}
inline ::google::protobuf::uint32 mp_item_base::row_size() const {
  return row_size_;
}
inline void mp_item_base::set_row_size(::google::protobuf::uint32 value) {
  _set_bit(18);
  row_size_ = value;
}

// optional uint32 col = 20;
inline bool mp_item_base::has_col() const {
  return _has_bit(19);
}
inline void mp_item_base::clear_col() {
  col_ = 0u;
  _clear_bit(19);
}
inline ::google::protobuf::uint32 mp_item_base::col() const {
  return col_;
}
inline void mp_item_base::set_col(::google::protobuf::uint32 value) {
  _set_bit(19);
  col_ = value;
}

// optional uint32 col_size = 21;
inline bool mp_item_base::has_col_size() const {
  return _has_bit(20);
}
inline void mp_item_base::clear_col_size() {
  col_size_ = 0u;
  _clear_bit(20);
}
inline ::google::protobuf::uint32 mp_item_base::col_size() const {
  return col_size_;
}
inline void mp_item_base::set_col_size(::google::protobuf::uint32 value) {
  _set_bit(20);
  col_size_ = value;
}

// optional uint32 level = 22;
inline bool mp_item_base::has_level() const {
  return _has_bit(21);
}
inline void mp_item_base::clear_level() {
  level_ = 0u;
  _clear_bit(21);
}
inline ::google::protobuf::uint32 mp_item_base::level() const {
  return level_;
}
inline void mp_item_base::set_level(::google::protobuf::uint32 value) {
  _set_bit(21);
  level_ = value;
}

// optional uint32 level_size = 23;
inline bool mp_item_base::has_level_size() const {
  return _has_bit(22);
}
inline void mp_item_base::clear_level_size() {
  level_size_ = 0u;
  _clear_bit(22);
}
inline ::google::protobuf::uint32 mp_item_base::level_size() const {
  return level_size_;
}
inline void mp_item_base::set_level_size(::google::protobuf::uint32 value) {
  _set_bit(22);
  level_size_ = value;
}

// optional uint32 area = 24;
inline bool mp_item_base::has_area() const {
  return _has_bit(23);
}
inline void mp_item_base::clear_area() {
  area_ = 0u;
  _clear_bit(23);
}
inline ::google::protobuf::uint32 mp_item_base::area() const {
  return area_;
}
inline void mp_item_base::set_area(::google::protobuf::uint32 value) {
  _set_bit(23);
  area_ = value;
}

// optional string para = 25;
inline bool mp_item_base::has_para() const {
  return _has_bit(24);
}
inline void mp_item_base::clear_para() {
  if (para_ != &_default_para_) {
    para_->clear();
  }
  _clear_bit(24);
}
inline const ::std::string& mp_item_base::para() const {
  return *para_;
}
inline void mp_item_base::set_para(const ::std::string& value) {
  _set_bit(24);
  if (para_ == &_default_para_) {
    para_ = new ::std::string;
  }
  para_->assign(value);
}
inline void mp_item_base::set_para(const char* value) {
  _set_bit(24);
  if (para_ == &_default_para_) {
    para_ = new ::std::string;
  }
  para_->assign(value);
}
inline void mp_item_base::set_para(const char* value, size_t size) {
  _set_bit(24);
  if (para_ == &_default_para_) {
    para_ = new ::std::string;
  }
  para_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_item_base::mutable_para() {
  _set_bit(24);
  if (para_ == &_default_para_) {
    para_ = new ::std::string;
  }
  return para_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace KPS

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KPS::mp_bind_io_Bind_IO_Type>() {
  return ::KPS::mp_bind_io_Bind_IO_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_2eproto__INCLUDED
