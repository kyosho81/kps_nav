#ifndef _ROBOT_STRUCT_WANGHONGTAO_20150831_
#define _ROBOT_STRUCT_WANGHONGTAO_20150831_


#include <vector>
#include <string>
#include "KHTypes.h"
#define LASER_COUNT 541
#define FPGA_LASER_BIN_CNT 512

#define LASER_COUNT_EX 8400
#define REFLECTOR_COUNT 100

//#define FPGA_LASER_BIN_CNT_256 256
//#define FPGA_LASER_BIN_CNT_512 512

//#define LASER_DIFF ((LASER_COUNT - FPGA_LASER_BIN_CNT) / 2)


#define LASER_COUNT_URG 1081

typedef enum{
	IDLE = 0,
	PLAN = 1,
	MOVE = 2,
	RECOVERY = 3,
	ERR = 4
}Status;

typedef enum{
	FRONT = 1,
	BACK = 2,
	LEFT = 3,
	RIGHT = 4
}Direction;

typedef enum
{
	dynamic = 1,
	fix = 2
}MODEL_TYPE;

typedef enum{
	NONE_ERR = 0,
	GLOBAL_PLANNER_ERR = 1,
	LOCAL_PLANNER_ERR = 2,
	OBSTACLE_DETECT = 3,
	AMCL_ERR = 4,
	OUT_OF_LINE_ERR = 5,
	STOPPING_ERR = 6,
	OBSTACLE_STOP = 7,
	COMMAND_STOP = 8,
	COLLISION_STOP = 9
}ERR_CODE;

typedef enum{
	DIFF2WD = 0,
	FORK_STEER = 1,
	FORK_DIFF = 2,
	SINGLE = 4,
	MULIT = 8,
	OMNI = 16,
	TYPE1 = 32,
	TYPE2 = 64
}Motion_type;

typedef enum{
	FIX_SLOW = 0, 
	FIX_STOP_IN = 1,
	FIX_STOP_OUT = 2,
	DY_ROT = 3,
	DY_ROTGO = 4
}Range_type;

typedef enum{
	SICK_LMS = 0, 
	SICK_TIM = 1,
	HOKUYO = 2,
	SAMTEC = 3,
	P_F_R2000 = 4,
	PAVO_LS20 = 5,
	SIM = 6
}Laser_type;

typedef enum{
	ID_MAP_SERVER = 100,
	ID_LOG_BAG = 200,
	ID_LOG_BAG_EX = 201
}Comm_Dev_Id;

typedef struct _SSerialNum
{

	U32 serial_num;
	U32 motion_type;
	U32 d1;
	U32 d2;
	U8 main_v;
	U8 sub_v;
	U8 c1;
	U8 c2;
}SSerialNum;

typedef struct _SGridXY
{
	U16 x_;
	U16 y_;
	S8 value_;

	S8 dir_;
	S8 speed_;
	S8 ptype_;

}SGridXY;

typedef struct _SLaser
{
	U32 stamp_;
	F32 start_angle_;
	F32 resolution_;	//
	F32 range_max_;
	F32 range_min_;

	F32 data_[LASER_COUNT];
	U8  seg_[LASER_COUNT];
	U32 used_;

} SLaser;

typedef struct _SLaser_Ex
{
	U32 stamp_;
	F32 dx_;
	F32 dy_;
	F32 start_angle_;
	F32 resolution_;	//
	F32 range_max_;
	F32 range_min_;
	F32 frame_dt_;

	F32 data_[LASER_COUNT_EX];
	U32 intensities_[LASER_COUNT_EX];
	U8  seg_[LASER_COUNT_EX];
	U32 used_;

} SLaser_Ex;



typedef struct _SLaser_para
{
	char ch_laser_ip_[500];
	bool reverse_;
	F32 laser_start_angle_;
	F32 laser_range_max_;
	F32 laser_range_min_;
	F32 laser_dx_;
	F32 laser_dy_;
	F32 laser_resolution_;

} SLaser_para;


typedef struct _SLaserXY
{

	F32 x_[LASER_COUNT];
	F32 y_[LASER_COUNT];
	U8 used_[LASER_COUNT];

} SLaserXY;

typedef struct _SPos
{
	F32 x_;
	F32 y_;
	F32 th_;

}SPos;

typedef struct _SSpeed
{
	F32 vx_;	//speed vx_
	F32 vy_;	//speed vy_
	F32 vw_;	//speed vw_

}SSpeed;

typedef struct _SOdomSpeed
{
	F32 x_;
	F32 y_;
	F32 th_;

	F32 vx_;	//speed vx_
	F32 vy_;	//speed vy_
	F32 vw_;	//speed vw_

}SOdomSpeed;

typedef struct _Sxy
{
	F32 x_;
	F32 y_;

}Sxy;

typedef struct _S16xy
{
	S16 x_;
	S16 y_;

}S16xy;

typedef struct _SLaser_xy
{
	F32 x_[LASER_COUNT];
	F32 y_[LASER_COUNT];
	U32 used_size_;

}SLaser_xy;


typedef struct _SPair_Odo_Laser
{

	SPos pos_;
	SLaser laser_;

}SPair_Odo_Laser;

typedef struct _SInit_Pos
{
	SPos pos_;

	U32 psize_;

	F32 para1_;
	F32 para2_;
	F32 para3_;
	F32 para4_;

}SInit_Pos;

typedef struct _STarget_Pos
{
	U8 model_;
	U8  stop_;
	U16 tmp2_;

	F32 x_;
	F32 y_;
	F32 th_;

}STarget_Pos;

typedef struct _SAMCL_RES
{

	F32 entropy_;
	F32 hz_;
	S32 stamp_;

}SAMCL_RES;

typedef struct _SparticleFAW
{

	F32 x;
	F32 y;
	F32 th;
	F32 aw;

}SparticleFAW;

typedef struct _SparticlePub
{
	U32 pwsize_;
	SparticleFAW data_w_[8192];

}SparticlePub;

typedef struct _Srecoder
{

	char cmd_file_[200];

}Srecoder;

typedef struct _SRunStatus
{

	Status status_;
	U8 err_code_;
	U8 arrived_;
	U8 back_;

	F32 sx_;
	F32 sy_;
	F32 sw_;

	F32 cx_;
	F32 cy_;
	F32 cw_;

}SRunStatus;

typedef struct _SVec
{
	F32 x_;
	F32 y_;

}SVec;

typedef struct _SLine2P
{
	SVec p1_;
	SVec p2_;

}SLine2P;

typedef struct _SLinePA
{
	SVec p_;
	F32 angle_;

}SLinePA;

typedef struct _SLocalShow
{
	SVec C_;
	SVec L_;
	SVec H_;

	F32 v_;
	F32 w_;

	SLinePA line_;

}LocalShow;

#define MAX_DI 24
#define MAX_DO 24
#define MAX_AI 8
#define MAX_AO 8

typedef struct _SDIAI
{
	U8 di_[MAX_DI];
	S32 ai_[MAX_AI];

}SDIAI;

typedef struct _SDOAO
{
	U8 do_[MAX_DO];
	S32 ao_[MAX_AO];

}SDOAO;

typedef struct _SDO
{
	U32 used_;
	U8 id_[MAX_DO];
	U8 do_[MAX_DO];

}SDO;

typedef struct _SAO
{
	U32 used_;
	U8 id_[MAX_AO];
	S32 ao_[MAX_AO];

}SAO;

typedef struct _SDI
{
	U32 used_;
	U8 id_[MAX_DI];
	S32 di_[MAX_DI];

}SDI;

typedef struct _SSub_task_upload
{
	U32 agv_id_;

	U32 sub_task_index_;
	U32 prority_;
	int current_step_;
	int max_step_;

	std::vector<SGridXY> run_path_;

}SSub_task_upload;

typedef struct _SSub_task_path
{
	U32 agv_id_;

	U32 sub_task_index_;
	U32 prority_;

	std::vector<SGridXY> run_path_;

}SSub_task_path;

typedef struct _SSub_task_path_aux
{
	U32 agv_id_;

	U32 sub_task_index_;
	U32 prority_;
	U32 max_step_;
}SSub_task_path_aux;


typedef struct _SSub_task_fnc
{
	U32 agv_id_;

	U32 sub_task_index_;
	U32 prority_;
	U32 function_code_; // 0 fork down 1 fork up  3 pos

	int current_step_;
	int max_step_;

}SSub_task_fnc;

typedef struct _SFork_state
{
	U32 fnc_code_;
	S32 para_;               //0 - 10000    mm
	S32 current_status_;     //0:action 1:finished

}SFork_state;


typedef struct _SControl
{
	U32 agv_id_;
	F32 max_speed_;
	int pause_run_slow;

}SControl;

#define THREAD_COUNTS   10

typedef struct _Health_Status
{
	F32 frequency[THREAD_COUNTS] ;     //unit :  Hz
	int error_code[THREAD_COUNTS];     //flag,  0:not work   1:low   2: normal
}Health_Status;


typedef enum{
	DEV_IDLE = 0,
	DEV_INIT = 1,
	DEV_RUN = 2,
	DEV_ERR = 3,
	DEV_toERR = 4
}eDEV_STATUS;

typedef enum{
	DEV_ERR_NONE = 0,
	DEV_ERR_INIT = 1,
	DEV_ERR_COMMUNICATE = 2,
	DEV_ERR_HZ = 3,
	DEV_ERR_INIT_POS =  4,
	DEV_ERR_REFLECTOR_IN = 5,
	DEV_ERR_REFLECTOR_NO_MATCH = 6,
	DEV_ERR_REFLECTOR_LS = 7,
	DEV_ERR_REFLECTOR_MTI_FOUND = 8,
}eDEV_ERR_CODE;

typedef struct _SDevStatus
{
	U8 device_id_;
	U8 status_;
	U16 err_code_;
	
	F32 cycle_ms_;
	F32 run_ms_;

}SDevStatus;

typedef struct _SPubDevStatus
{
	SDevStatus dev_status_;
	char name_[200];

}SPubDevStatus;

typedef struct _SCmd
{
	char cmd_str_[200];
}SCmd;

typedef struct _SLaser_used
{
	F32 angle_;
	F32 dis_;

}SLaser_used;


typedef struct _SReflash_map
{
	
	typedef enum{
		AMCL_RUN,
		AMCL_STOP,
		AMCL_REFLASH
	}REF_TYPE;

	REF_TYPE ref_type_;

}SReflash_map;

typedef struct _STriangle {

	F32 x;
	F32 y;
	F32 angle;
	F32 weight;

	SVec points[3];
	S32 color;

} STriangle;

typedef struct _SRemote_data{

	U8 key1_;
	U8 key2_;
	U8 key3_;
	U16 new_ad1_;
	U16 new_ad2_;
	S32 sequence_;

}SRemote_data;

typedef enum{

	BAG_IDLE = 200,
	BAG_LOGGING = 201,
	BAG_PLAYBACK = 202,
	BAG_PLAYBACK_WAIT = 203,
	BAG_IDLE_LOGGING = 204,
	BAG_IDLE_PLAYBACK = 205,
  //BAG_IDLE_UPLOAD = 6,
	BAG_LOGGING_IDLE = 207,
	BAG_PLAYBACK_IDLE = 208,
	BAG_UPLOAD = 209,
	BAG_ERR = 2010

}eBAG_STATUS;

typedef struct _SPUB_BAG
{
	SOdomSpeed odom_;
	SLaser laser_;
	SPos amcl_pos_;
	SLaser_para laser_para_;
	char robot_shape_[500];
}SPUB_BAG;

typedef enum{

	MAP_IDLE = 100,
	MAP_RUN_MAPPING = 101,
	MAP_BAG_MAPPING = 102,
	MAP_IDLE_RUN_MAPPING = 103,
	MAP_IDLE_BAG_MAPPING = 104,
	MAP_RUN_MAPPING_IDLE = 105,
	MAP_BAG_MAPPING_IDLE = 106,
	MAP_SAVE_MAP = 107,
	MAP_SHOW_MAP = 108

}eMAP_STATUS;

// typedef struct _SPubStatus
// {
// 	
// 	U8 device_id_;
// 	U8 status_;
// 	U16 err_code_;
// 
// 	char name_[200];
// 	char ms_str_[200];
// 
// }SPubStatus;

typedef struct _SProcess_Bar
{
	U32 max_step_;
	U32 current_step_;

	char name_[200];

}SProcess_Bar;

typedef struct _SDynamic_Speed
{
	U8 id_;			   //id stand for one kind of speed limit type
	U16 control_time_;  //10 means speed limit continue in 10 seconds
	U8 back_;

	F32 vx_;
	F32 vy_;
	F32 vw_;


}SDynamic_Speed;

typedef struct _SRunPath
{
	U8 replan_;
	U8 backward_;
	U8 tmp1_;
	U8 tmp2_;
	char path_name_[200];

}SRunPath;

typedef enum{
	PATH_STATUS_ERR = 0,
	PATH_STATUS_AWAY = 1,
	PATH_STATUS_CLOSE = 2
}EPath_status;

typedef enum{
	PATH_SEG = 0,
	PATH_ROT = 1,
	PATH_ARC = 2
}EPath_type;

typedef struct _SPathData
{
	SPos tn_from_;
	SPos tn_to_;
	EPath_type p_type_;
	F32 complete_pre_;
	F32 speed_from_;
	F32 speed_;
	S32 starter_from_;
	S32 starter_to_;
	char desc_from_[500];
	char desc_to_[500];

}SPathData;

typedef struct _SCHK_LASER_RANGE
{
	SLaser laser_;
	Range_type type_;

}SCHK_LASER_RANGE;

typedef struct _SIMURION
{
	F32 acc_;
	F32 w_;
	F32 th_;

}SIMURION;

typedef struct _SLaser_Landmark
{
	U8 numbers;
	F32 Position_x[LASER_COUNT];
	F32 Position_y[LASER_COUNT];
	F32 orient[LASER_COUNT];
	S32 ID[LASER_COUNT];
} SLaser_Landmark;

typedef struct _SPair_SVec
{
	bool b_selected_;
	int id_from_;
	int id_to_;
	int bind_global_id_;
	F32 dis_;

	void clear(){
		b_selected_ = false;
		id_from_ = 0;
		id_to_ = 0;
		bind_global_id_ = 0;
		dis_ = 0;
	};
}SPair_SVec;

typedef struct _SReflector
{
	int id_[REFLECTOR_COUNT];
	SVec pos_[REFLECTOR_COUNT];
	U8 used_;
}SReflector;

typedef struct _SLaser_Ex_Ref
{
	SLaser_Ex laser_ex_;
	SReflector laser_reflector_;

} SLaser_Ex_Ref;



typedef struct _SPUB_BAG_EX
{
	SOdomSpeed odom_;
	SLaser_Ex_Ref laser_ex_ref_;
	SPos amcl_pos_;
	SLaser_para laser_para_;
	char robot_shape_[500];
}SPUB_BAG_EX;


typedef struct _SLoopCLosurePos
{
	SPos pos_;
	F32 confidence_;

}SLoopCLosurePos;


typedef struct _SAMCL_CONFIDENCE
{
	
	bool b_amcl_confidence_;
	F32 amcl_confidence_;

}SAMCL_CONFIDENCE;

typedef struct _SAMCL_ENTROPY
{

	bool b_amcl_entropy_;
	F32 amcl_xy_entropy_;
	F32 amcl_theta_entropy_;
	F32 amcl_entropy_;

}SAMCL_ENTROPY;


typedef struct _SLOG_BAG
{
	SPUB_BAG pub_bag_;
	SAMCL_CONFIDENCE amcl_confidence_;

}SLOG_BAG;

#endif//_ROBOT_STRUCT_WANGHONGTAO_20150831_

