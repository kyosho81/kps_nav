// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GChassic.proto

#ifndef PROTOBUF_GChassic_2eproto__INCLUDED
#define PROTOBUF_GChassic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GChassic_2eproto();
void protobuf_AssignDesc_GChassic_2eproto();
void protobuf_ShutdownFile_GChassic_2eproto();

class GMotorSet;
class GRobotSpeed;
class GRobotPWM;
class GRobotSpeedControl;
class GOdometer;
class GChassicData;
class GMotorDebugMessage;
class GChassicDebugMessage;

enum GRobotSpeed_ControlMode {
  GRobotSpeed_ControlMode_COMBINE = 1,
  GRobotSpeed_ControlMode_SEPARATELY = 2,
  GRobotSpeed_ControlMode_BOTH = 3
};
bool GRobotSpeed_ControlMode_IsValid(int value);
const GRobotSpeed_ControlMode GRobotSpeed_ControlMode_ControlMode_MIN = GRobotSpeed_ControlMode_COMBINE;
const GRobotSpeed_ControlMode GRobotSpeed_ControlMode_ControlMode_MAX = GRobotSpeed_ControlMode_BOTH;
const int GRobotSpeed_ControlMode_ControlMode_ARRAYSIZE = GRobotSpeed_ControlMode_ControlMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GRobotSpeed_ControlMode_descriptor();
inline const ::std::string& GRobotSpeed_ControlMode_Name(GRobotSpeed_ControlMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GRobotSpeed_ControlMode_descriptor(), value);
}
inline bool GRobotSpeed_ControlMode_Parse(
    const ::std::string& name, GRobotSpeed_ControlMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GRobotSpeed_ControlMode>(
    GRobotSpeed_ControlMode_descriptor(), name, value);
}
enum GRobotSpeedControl_RobotSpeedControlType {
  GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_CONTROL = 1,
  GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_SET_LEVEL = 2,
  GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_MOTOR_GUARD = 3,
  GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_GUARD_CLEAR = 4,
  GRobotSpeedControl_RobotSpeedControlType_ROBOT_PWM_CONTROL = 5,
  GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_DISABLE = 6
};
bool GRobotSpeedControl_RobotSpeedControlType_IsValid(int value);
const GRobotSpeedControl_RobotSpeedControlType GRobotSpeedControl_RobotSpeedControlType_RobotSpeedControlType_MIN = GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_CONTROL;
const GRobotSpeedControl_RobotSpeedControlType GRobotSpeedControl_RobotSpeedControlType_RobotSpeedControlType_MAX = GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_DISABLE;
const int GRobotSpeedControl_RobotSpeedControlType_RobotSpeedControlType_ARRAYSIZE = GRobotSpeedControl_RobotSpeedControlType_RobotSpeedControlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GRobotSpeedControl_RobotSpeedControlType_descriptor();
inline const ::std::string& GRobotSpeedControl_RobotSpeedControlType_Name(GRobotSpeedControl_RobotSpeedControlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GRobotSpeedControl_RobotSpeedControlType_descriptor(), value);
}
inline bool GRobotSpeedControl_RobotSpeedControlType_Parse(
    const ::std::string& name, GRobotSpeedControl_RobotSpeedControlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GRobotSpeedControl_RobotSpeedControlType>(
    GRobotSpeedControl_RobotSpeedControlType_descriptor(), name, value);
}
enum GOdometer_OdometerMode {
  GOdometer_OdometerMode_COMBINE = 1,
  GOdometer_OdometerMode_SEPARATELY = 2
};
bool GOdometer_OdometerMode_IsValid(int value);
const GOdometer_OdometerMode GOdometer_OdometerMode_OdometerMode_MIN = GOdometer_OdometerMode_COMBINE;
const GOdometer_OdometerMode GOdometer_OdometerMode_OdometerMode_MAX = GOdometer_OdometerMode_SEPARATELY;
const int GOdometer_OdometerMode_OdometerMode_ARRAYSIZE = GOdometer_OdometerMode_OdometerMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GOdometer_OdometerMode_descriptor();
inline const ::std::string& GOdometer_OdometerMode_Name(GOdometer_OdometerMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GOdometer_OdometerMode_descriptor(), value);
}
inline bool GOdometer_OdometerMode_Parse(
    const ::std::string& name, GOdometer_OdometerMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GOdometer_OdometerMode>(
    GOdometer_OdometerMode_descriptor(), name, value);
}
// ===================================================================

class GMotorSet : public ::google::protobuf::Message {
 public:
  GMotorSet();
  virtual ~GMotorSet();
  
  GMotorSet(const GMotorSet& from);
  
  inline GMotorSet& operator=(const GMotorSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GMotorSet& default_instance();
  
  void Swap(GMotorSet* other);
  
  // implements Message ----------------------------------------------
  
  GMotorSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMotorSet& from);
  void MergeFrom(const GMotorSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double speed = 1;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 1;
  inline double speed() const;
  inline void set_speed(double value);
  
  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GMotorSet)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double speed_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_GChassic_2eproto();
  friend void protobuf_AssignDesc_GChassic_2eproto();
  friend void protobuf_ShutdownFile_GChassic_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GMotorSet* default_instance_;
};
// -------------------------------------------------------------------

class GRobotSpeed : public ::google::protobuf::Message {
 public:
  GRobotSpeed();
  virtual ~GRobotSpeed();
  
  GRobotSpeed(const GRobotSpeed& from);
  
  inline GRobotSpeed& operator=(const GRobotSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GRobotSpeed& default_instance();
  
  void Swap(GRobotSpeed* other);
  
  // implements Message ----------------------------------------------
  
  GRobotSpeed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GRobotSpeed& from);
  void MergeFrom(const GRobotSpeed& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GRobotSpeed_ControlMode ControlMode;
  static const ControlMode COMBINE = GRobotSpeed_ControlMode_COMBINE;
  static const ControlMode SEPARATELY = GRobotSpeed_ControlMode_SEPARATELY;
  static const ControlMode BOTH = GRobotSpeed_ControlMode_BOTH;
  static inline bool ControlMode_IsValid(int value) {
    return GRobotSpeed_ControlMode_IsValid(value);
  }
  static const ControlMode ControlMode_MIN =
    GRobotSpeed_ControlMode_ControlMode_MIN;
  static const ControlMode ControlMode_MAX =
    GRobotSpeed_ControlMode_ControlMode_MAX;
  static const int ControlMode_ARRAYSIZE =
    GRobotSpeed_ControlMode_ControlMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ControlMode_descriptor() {
    return GRobotSpeed_ControlMode_descriptor();
  }
  static inline const ::std::string& ControlMode_Name(ControlMode value) {
    return GRobotSpeed_ControlMode_Name(value);
  }
  static inline bool ControlMode_Parse(const ::std::string& name,
      ControlMode* value) {
    return GRobotSpeed_ControlMode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .GRobotSpeed.ControlMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::GRobotSpeed_ControlMode mode() const;
  inline void set_mode(::GRobotSpeed_ControlMode value);
  
  // optional double vx = 2;
  inline bool has_vx() const;
  inline void clear_vx();
  static const int kVxFieldNumber = 2;
  inline double vx() const;
  inline void set_vx(double value);
  
  // optional double vy = 3;
  inline bool has_vy() const;
  inline void clear_vy();
  static const int kVyFieldNumber = 3;
  inline double vy() const;
  inline void set_vy(double value);
  
  // optional double w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline double w() const;
  inline void set_w(double value);
  
  // repeated .GMotorSet motors = 5;
  inline int motors_size() const;
  inline void clear_motors();
  static const int kMotorsFieldNumber = 5;
  inline const ::GMotorSet& motors(int index) const;
  inline ::GMotorSet* mutable_motors(int index);
  inline ::GMotorSet* add_motors();
  inline const ::google::protobuf::RepeatedPtrField< ::GMotorSet >&
      motors() const;
  inline ::google::protobuf::RepeatedPtrField< ::GMotorSet >*
      mutable_motors();
  
  // @@protoc_insertion_point(class_scope:GRobotSpeed)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int mode_;
  double vx_;
  double vy_;
  double w_;
  ::google::protobuf::RepeatedPtrField< ::GMotorSet > motors_;
  friend void  protobuf_AddDesc_GChassic_2eproto();
  friend void protobuf_AssignDesc_GChassic_2eproto();
  friend void protobuf_ShutdownFile_GChassic_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GRobotSpeed* default_instance_;
};
// -------------------------------------------------------------------

class GRobotPWM : public ::google::protobuf::Message {
 public:
  GRobotPWM();
  virtual ~GRobotPWM();
  
  GRobotPWM(const GRobotPWM& from);
  
  inline GRobotPWM& operator=(const GRobotPWM& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GRobotPWM& default_instance();
  
  void Swap(GRobotPWM* other);
  
  // implements Message ----------------------------------------------
  
  GRobotPWM* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GRobotPWM& from);
  void MergeFrom(const GRobotPWM& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 d1 = 1;
  inline bool has_d1() const;
  inline void clear_d1();
  static const int kD1FieldNumber = 1;
  inline ::google::protobuf::int32 d1() const;
  inline void set_d1(::google::protobuf::int32 value);
  
  // optional int32 d2 = 2;
  inline bool has_d2() const;
  inline void clear_d2();
  static const int kD2FieldNumber = 2;
  inline ::google::protobuf::int32 d2() const;
  inline void set_d2(::google::protobuf::int32 value);
  
  // optional int32 d3 = 3;
  inline bool has_d3() const;
  inline void clear_d3();
  static const int kD3FieldNumber = 3;
  inline ::google::protobuf::int32 d3() const;
  inline void set_d3(::google::protobuf::int32 value);
  
  // optional int32 d4 = 4;
  inline bool has_d4() const;
  inline void clear_d4();
  static const int kD4FieldNumber = 4;
  inline ::google::protobuf::int32 d4() const;
  inline void set_d4(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GRobotPWM)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 d1_;
  ::google::protobuf::int32 d2_;
  ::google::protobuf::int32 d3_;
  ::google::protobuf::int32 d4_;
  friend void  protobuf_AddDesc_GChassic_2eproto();
  friend void protobuf_AssignDesc_GChassic_2eproto();
  friend void protobuf_ShutdownFile_GChassic_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GRobotPWM* default_instance_;
};
// -------------------------------------------------------------------

class GRobotSpeedControl : public ::google::protobuf::Message {
 public:
  GRobotSpeedControl();
  virtual ~GRobotSpeedControl();
  
  GRobotSpeedControl(const GRobotSpeedControl& from);
  
  inline GRobotSpeedControl& operator=(const GRobotSpeedControl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GRobotSpeedControl& default_instance();
  
  void Swap(GRobotSpeedControl* other);
  
  // implements Message ----------------------------------------------
  
  GRobotSpeedControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GRobotSpeedControl& from);
  void MergeFrom(const GRobotSpeedControl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GRobotSpeedControl_RobotSpeedControlType RobotSpeedControlType;
  static const RobotSpeedControlType ROBOT_SPEED_CONTROL = GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_CONTROL;
  static const RobotSpeedControlType ROBOT_SPEED_SET_LEVEL = GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_SET_LEVEL;
  static const RobotSpeedControlType ROBOT_SPEED_MOTOR_GUARD = GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_MOTOR_GUARD;
  static const RobotSpeedControlType ROBOT_SPEED_GUARD_CLEAR = GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_GUARD_CLEAR;
  static const RobotSpeedControlType ROBOT_PWM_CONTROL = GRobotSpeedControl_RobotSpeedControlType_ROBOT_PWM_CONTROL;
  static const RobotSpeedControlType ROBOT_SPEED_DISABLE = GRobotSpeedControl_RobotSpeedControlType_ROBOT_SPEED_DISABLE;
  static inline bool RobotSpeedControlType_IsValid(int value) {
    return GRobotSpeedControl_RobotSpeedControlType_IsValid(value);
  }
  static const RobotSpeedControlType RobotSpeedControlType_MIN =
    GRobotSpeedControl_RobotSpeedControlType_RobotSpeedControlType_MIN;
  static const RobotSpeedControlType RobotSpeedControlType_MAX =
    GRobotSpeedControl_RobotSpeedControlType_RobotSpeedControlType_MAX;
  static const int RobotSpeedControlType_ARRAYSIZE =
    GRobotSpeedControl_RobotSpeedControlType_RobotSpeedControlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RobotSpeedControlType_descriptor() {
    return GRobotSpeedControl_RobotSpeedControlType_descriptor();
  }
  static inline const ::std::string& RobotSpeedControlType_Name(RobotSpeedControlType value) {
    return GRobotSpeedControl_RobotSpeedControlType_Name(value);
  }
  static inline bool RobotSpeedControlType_Parse(const ::std::string& name,
      RobotSpeedControlType* value) {
    return GRobotSpeedControl_RobotSpeedControlType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .GRobotSpeedControl.RobotSpeedControlType type = 1 [default = ROBOT_SPEED_CONTROL];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GRobotSpeedControl_RobotSpeedControlType type() const;
  inline void set_type(::GRobotSpeedControl_RobotSpeedControlType value);
  
  // optional .GRobotSpeed speed = 2;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 2;
  inline const ::GRobotSpeed& speed() const;
  inline ::GRobotSpeed* mutable_speed();
  
  // optional int32 level = 3 [default = 1];
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // optional .GRobotPWM pwm = 4;
  inline bool has_pwm() const;
  inline void clear_pwm();
  static const int kPwmFieldNumber = 4;
  inline const ::GRobotPWM& pwm() const;
  inline ::GRobotPWM* mutable_pwm();
  
  // optional int32 clean = 5;
  inline bool has_clean() const;
  inline void clear_clean();
  static const int kCleanFieldNumber = 5;
  inline ::google::protobuf::int32 clean() const;
  inline void set_clean(::google::protobuf::int32 value);
  
  // optional string nodeName = 6;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodeNameFieldNumber = 6;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  
  // @@protoc_insertion_point(class_scope:GRobotSpeedControl)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::GRobotSpeed* speed_;
  ::google::protobuf::int32 level_;
  ::GRobotPWM* pwm_;
  ::google::protobuf::int32 clean_;
  ::std::string* nodename_;
  static const ::std::string _default_nodename_;
  friend void  protobuf_AddDesc_GChassic_2eproto();
  friend void protobuf_AssignDesc_GChassic_2eproto();
  friend void protobuf_ShutdownFile_GChassic_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GRobotSpeedControl* default_instance_;
};
// -------------------------------------------------------------------

class GOdometer : public ::google::protobuf::Message {
 public:
  GOdometer();
  virtual ~GOdometer();
  
  GOdometer(const GOdometer& from);
  
  inline GOdometer& operator=(const GOdometer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GOdometer& default_instance();
  
  void Swap(GOdometer* other);
  
  // implements Message ----------------------------------------------
  
  GOdometer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GOdometer& from);
  void MergeFrom(const GOdometer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GOdometer_OdometerMode OdometerMode;
  static const OdometerMode COMBINE = GOdometer_OdometerMode_COMBINE;
  static const OdometerMode SEPARATELY = GOdometer_OdometerMode_SEPARATELY;
  static inline bool OdometerMode_IsValid(int value) {
    return GOdometer_OdometerMode_IsValid(value);
  }
  static const OdometerMode OdometerMode_MIN =
    GOdometer_OdometerMode_OdometerMode_MIN;
  static const OdometerMode OdometerMode_MAX =
    GOdometer_OdometerMode_OdometerMode_MAX;
  static const int OdometerMode_ARRAYSIZE =
    GOdometer_OdometerMode_OdometerMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OdometerMode_descriptor() {
    return GOdometer_OdometerMode_descriptor();
  }
  static inline const ::std::string& OdometerMode_Name(OdometerMode value) {
    return GOdometer_OdometerMode_Name(value);
  }
  static inline bool OdometerMode_Parse(const ::std::string& name,
      OdometerMode* value) {
    return GOdometer_OdometerMode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .GOdometer.OdometerMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::GOdometer_OdometerMode mode() const;
  inline void set_mode(::GOdometer_OdometerMode value);
  
  // optional double x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline double x() const;
  inline void set_x(double value);
  
  // optional double y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline double y() const;
  inline void set_y(double value);
  
  // optional double angle = 4;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 4;
  inline double angle() const;
  inline void set_angle(double value);
  
  // repeated .GMotorSet motors = 5;
  inline int motors_size() const;
  inline void clear_motors();
  static const int kMotorsFieldNumber = 5;
  inline const ::GMotorSet& motors(int index) const;
  inline ::GMotorSet* mutable_motors(int index);
  inline ::GMotorSet* add_motors();
  inline const ::google::protobuf::RepeatedPtrField< ::GMotorSet >&
      motors() const;
  inline ::google::protobuf::RepeatedPtrField< ::GMotorSet >*
      mutable_motors();
  
  // @@protoc_insertion_point(class_scope:GOdometer)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int mode_;
  double x_;
  double y_;
  double angle_;
  ::google::protobuf::RepeatedPtrField< ::GMotorSet > motors_;
  friend void  protobuf_AddDesc_GChassic_2eproto();
  friend void protobuf_AssignDesc_GChassic_2eproto();
  friend void protobuf_ShutdownFile_GChassic_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GOdometer* default_instance_;
};
// -------------------------------------------------------------------

class GChassicData : public ::google::protobuf::Message {
 public:
  GChassicData();
  virtual ~GChassicData();
  
  GChassicData(const GChassicData& from);
  
  inline GChassicData& operator=(const GChassicData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GChassicData& default_instance();
  
  void Swap(GChassicData* other);
  
  // implements Message ----------------------------------------------
  
  GChassicData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GChassicData& from);
  void MergeFrom(const GChassicData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .GOdometer odometer = 1;
  inline bool has_odometer() const;
  inline void clear_odometer();
  static const int kOdometerFieldNumber = 1;
  inline const ::GOdometer& odometer() const;
  inline ::GOdometer* mutable_odometer();
  
  // optional .GRobotSpeed speed = 2;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 2;
  inline const ::GRobotSpeed& speed() const;
  inline ::GRobotSpeed* mutable_speed();
  
  // optional .GRobotPWM pwm = 3;
  inline bool has_pwm() const;
  inline void clear_pwm();
  static const int kPwmFieldNumber = 3;
  inline const ::GRobotPWM& pwm() const;
  inline ::GRobotPWM* mutable_pwm();
  
  // optional double time_stamp = 4;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 4;
  inline double time_stamp() const;
  inline void set_time_stamp(double value);
  
  // @@protoc_insertion_point(class_scope:GChassicData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::GOdometer* odometer_;
  ::GRobotSpeed* speed_;
  ::GRobotPWM* pwm_;
  double time_stamp_;
  friend void  protobuf_AddDesc_GChassic_2eproto();
  friend void protobuf_AssignDesc_GChassic_2eproto();
  friend void protobuf_ShutdownFile_GChassic_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GChassicData* default_instance_;
};
// -------------------------------------------------------------------

class GMotorDebugMessage : public ::google::protobuf::Message {
 public:
  GMotorDebugMessage();
  virtual ~GMotorDebugMessage();
  
  GMotorDebugMessage(const GMotorDebugMessage& from);
  
  inline GMotorDebugMessage& operator=(const GMotorDebugMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GMotorDebugMessage& default_instance();
  
  void Swap(GMotorDebugMessage* other);
  
  // implements Message ----------------------------------------------
  
  GMotorDebugMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMotorDebugMessage& from);
  void MergeFrom(const GMotorDebugMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional double current = 2;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 2;
  inline double current() const;
  inline void set_current(double value);
  
  // optional double voltage = 3;
  inline bool has_voltage() const;
  inline void clear_voltage();
  static const int kVoltageFieldNumber = 3;
  inline double voltage() const;
  inline void set_voltage(double value);
  
  // optional double targetVel = 4;
  inline bool has_targetvel() const;
  inline void clear_targetvel();
  static const int kTargetVelFieldNumber = 4;
  inline double targetvel() const;
  inline void set_targetvel(double value);
  
  // optional double actualVel = 5;
  inline bool has_actualvel() const;
  inline void clear_actualvel();
  static const int kActualVelFieldNumber = 5;
  inline double actualvel() const;
  inline void set_actualvel(double value);
  
  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  
  // optional int32 errorType = 7;
  inline bool has_errortype() const;
  inline void clear_errortype();
  static const int kErrorTypeFieldNumber = 7;
  inline ::google::protobuf::int32 errortype() const;
  inline void set_errortype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GMotorDebugMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  double current_;
  double voltage_;
  double targetvel_;
  double actualvel_;
  ::std::string* description_;
  static const ::std::string _default_description_;
  ::google::protobuf::int32 errortype_;
  friend void  protobuf_AddDesc_GChassic_2eproto();
  friend void protobuf_AssignDesc_GChassic_2eproto();
  friend void protobuf_ShutdownFile_GChassic_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GMotorDebugMessage* default_instance_;
};
// -------------------------------------------------------------------

class GChassicDebugMessage : public ::google::protobuf::Message {
 public:
  GChassicDebugMessage();
  virtual ~GChassicDebugMessage();
  
  GChassicDebugMessage(const GChassicDebugMessage& from);
  
  inline GChassicDebugMessage& operator=(const GChassicDebugMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GChassicDebugMessage& default_instance();
  
  void Swap(GChassicDebugMessage* other);
  
  // implements Message ----------------------------------------------
  
  GChassicDebugMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GChassicDebugMessage& from);
  void MergeFrom(const GChassicDebugMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 errorType = 1;
  inline bool has_errortype() const;
  inline void clear_errortype();
  static const int kErrorTypeFieldNumber = 1;
  inline ::google::protobuf::int32 errortype() const;
  inline void set_errortype(::google::protobuf::int32 value);
  
  // optional string errorDesption = 2;
  inline bool has_errordesption() const;
  inline void clear_errordesption();
  static const int kErrorDesptionFieldNumber = 2;
  inline const ::std::string& errordesption() const;
  inline void set_errordesption(const ::std::string& value);
  inline void set_errordesption(const char* value);
  inline void set_errordesption(const char* value, size_t size);
  inline ::std::string* mutable_errordesption();
  
  // repeated .GMotorDebugMessage motors = 3;
  inline int motors_size() const;
  inline void clear_motors();
  static const int kMotorsFieldNumber = 3;
  inline const ::GMotorDebugMessage& motors(int index) const;
  inline ::GMotorDebugMessage* mutable_motors(int index);
  inline ::GMotorDebugMessage* add_motors();
  inline const ::google::protobuf::RepeatedPtrField< ::GMotorDebugMessage >&
      motors() const;
  inline ::google::protobuf::RepeatedPtrField< ::GMotorDebugMessage >*
      mutable_motors();
  
  // @@protoc_insertion_point(class_scope:GChassicDebugMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 errortype_;
  ::std::string* errordesption_;
  static const ::std::string _default_errordesption_;
  ::google::protobuf::RepeatedPtrField< ::GMotorDebugMessage > motors_;
  friend void  protobuf_AddDesc_GChassic_2eproto();
  friend void protobuf_AssignDesc_GChassic_2eproto();
  friend void protobuf_ShutdownFile_GChassic_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GChassicDebugMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// GMotorSet

// optional double speed = 1;
inline bool GMotorSet::has_speed() const {
  return _has_bit(0);
}
inline void GMotorSet::clear_speed() {
  speed_ = 0;
  _clear_bit(0);
}
inline double GMotorSet::speed() const {
  return speed_;
}
inline void GMotorSet::set_speed(double value) {
  _set_bit(0);
  speed_ = value;
}

// optional int32 id = 2;
inline bool GMotorSet::has_id() const {
  return _has_bit(1);
}
inline void GMotorSet::clear_id() {
  id_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 GMotorSet::id() const {
  return id_;
}
inline void GMotorSet::set_id(::google::protobuf::int32 value) {
  _set_bit(1);
  id_ = value;
}

// -------------------------------------------------------------------

// GRobotSpeed

// optional .GRobotSpeed.ControlMode mode = 1;
inline bool GRobotSpeed::has_mode() const {
  return _has_bit(0);
}
inline void GRobotSpeed::clear_mode() {
  mode_ = 1;
  _clear_bit(0);
}
inline ::GRobotSpeed_ControlMode GRobotSpeed::mode() const {
  return static_cast< ::GRobotSpeed_ControlMode >(mode_);
}
inline void GRobotSpeed::set_mode(::GRobotSpeed_ControlMode value) {
  GOOGLE_DCHECK(::GRobotSpeed_ControlMode_IsValid(value));
  _set_bit(0);
  mode_ = value;
}

// optional double vx = 2;
inline bool GRobotSpeed::has_vx() const {
  return _has_bit(1);
}
inline void GRobotSpeed::clear_vx() {
  vx_ = 0;
  _clear_bit(1);
}
inline double GRobotSpeed::vx() const {
  return vx_;
}
inline void GRobotSpeed::set_vx(double value) {
  _set_bit(1);
  vx_ = value;
}

// optional double vy = 3;
inline bool GRobotSpeed::has_vy() const {
  return _has_bit(2);
}
inline void GRobotSpeed::clear_vy() {
  vy_ = 0;
  _clear_bit(2);
}
inline double GRobotSpeed::vy() const {
  return vy_;
}
inline void GRobotSpeed::set_vy(double value) {
  _set_bit(2);
  vy_ = value;
}

// optional double w = 4;
inline bool GRobotSpeed::has_w() const {
  return _has_bit(3);
}
inline void GRobotSpeed::clear_w() {
  w_ = 0;
  _clear_bit(3);
}
inline double GRobotSpeed::w() const {
  return w_;
}
inline void GRobotSpeed::set_w(double value) {
  _set_bit(3);
  w_ = value;
}

// repeated .GMotorSet motors = 5;
inline int GRobotSpeed::motors_size() const {
  return motors_.size();
}
inline void GRobotSpeed::clear_motors() {
  motors_.Clear();
}
inline const ::GMotorSet& GRobotSpeed::motors(int index) const {
  return motors_.Get(index);
}
inline ::GMotorSet* GRobotSpeed::mutable_motors(int index) {
  return motors_.Mutable(index);
}
inline ::GMotorSet* GRobotSpeed::add_motors() {
  return motors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GMotorSet >&
GRobotSpeed::motors() const {
  return motors_;
}
inline ::google::protobuf::RepeatedPtrField< ::GMotorSet >*
GRobotSpeed::mutable_motors() {
  return &motors_;
}

// -------------------------------------------------------------------

// GRobotPWM

// optional int32 d1 = 1;
inline bool GRobotPWM::has_d1() const {
  return _has_bit(0);
}
inline void GRobotPWM::clear_d1() {
  d1_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 GRobotPWM::d1() const {
  return d1_;
}
inline void GRobotPWM::set_d1(::google::protobuf::int32 value) {
  _set_bit(0);
  d1_ = value;
}

// optional int32 d2 = 2;
inline bool GRobotPWM::has_d2() const {
  return _has_bit(1);
}
inline void GRobotPWM::clear_d2() {
  d2_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 GRobotPWM::d2() const {
  return d2_;
}
inline void GRobotPWM::set_d2(::google::protobuf::int32 value) {
  _set_bit(1);
  d2_ = value;
}

// optional int32 d3 = 3;
inline bool GRobotPWM::has_d3() const {
  return _has_bit(2);
}
inline void GRobotPWM::clear_d3() {
  d3_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 GRobotPWM::d3() const {
  return d3_;
}
inline void GRobotPWM::set_d3(::google::protobuf::int32 value) {
  _set_bit(2);
  d3_ = value;
}

// optional int32 d4 = 4;
inline bool GRobotPWM::has_d4() const {
  return _has_bit(3);
}
inline void GRobotPWM::clear_d4() {
  d4_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 GRobotPWM::d4() const {
  return d4_;
}
inline void GRobotPWM::set_d4(::google::protobuf::int32 value) {
  _set_bit(3);
  d4_ = value;
}

// -------------------------------------------------------------------

// GRobotSpeedControl

// optional .GRobotSpeedControl.RobotSpeedControlType type = 1 [default = ROBOT_SPEED_CONTROL];
inline bool GRobotSpeedControl::has_type() const {
  return _has_bit(0);
}
inline void GRobotSpeedControl::clear_type() {
  type_ = 1;
  _clear_bit(0);
}
inline ::GRobotSpeedControl_RobotSpeedControlType GRobotSpeedControl::type() const {
  return static_cast< ::GRobotSpeedControl_RobotSpeedControlType >(type_);
}
inline void GRobotSpeedControl::set_type(::GRobotSpeedControl_RobotSpeedControlType value) {
  GOOGLE_DCHECK(::GRobotSpeedControl_RobotSpeedControlType_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional .GRobotSpeed speed = 2;
inline bool GRobotSpeedControl::has_speed() const {
  return _has_bit(1);
}
inline void GRobotSpeedControl::clear_speed() {
  if (speed_ != NULL) speed_->::GRobotSpeed::Clear();
  _clear_bit(1);
}
inline const ::GRobotSpeed& GRobotSpeedControl::speed() const {
  return speed_ != NULL ? *speed_ : *default_instance_->speed_;
}
inline ::GRobotSpeed* GRobotSpeedControl::mutable_speed() {
  _set_bit(1);
  if (speed_ == NULL) speed_ = new ::GRobotSpeed;
  return speed_;
}

// optional int32 level = 3 [default = 1];
inline bool GRobotSpeedControl::has_level() const {
  return _has_bit(2);
}
inline void GRobotSpeedControl::clear_level() {
  level_ = 1;
  _clear_bit(2);
}
inline ::google::protobuf::int32 GRobotSpeedControl::level() const {
  return level_;
}
inline void GRobotSpeedControl::set_level(::google::protobuf::int32 value) {
  _set_bit(2);
  level_ = value;
}

// optional .GRobotPWM pwm = 4;
inline bool GRobotSpeedControl::has_pwm() const {
  return _has_bit(3);
}
inline void GRobotSpeedControl::clear_pwm() {
  if (pwm_ != NULL) pwm_->::GRobotPWM::Clear();
  _clear_bit(3);
}
inline const ::GRobotPWM& GRobotSpeedControl::pwm() const {
  return pwm_ != NULL ? *pwm_ : *default_instance_->pwm_;
}
inline ::GRobotPWM* GRobotSpeedControl::mutable_pwm() {
  _set_bit(3);
  if (pwm_ == NULL) pwm_ = new ::GRobotPWM;
  return pwm_;
}

// optional int32 clean = 5;
inline bool GRobotSpeedControl::has_clean() const {
  return _has_bit(4);
}
inline void GRobotSpeedControl::clear_clean() {
  clean_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 GRobotSpeedControl::clean() const {
  return clean_;
}
inline void GRobotSpeedControl::set_clean(::google::protobuf::int32 value) {
  _set_bit(4);
  clean_ = value;
}

// optional string nodeName = 6;
inline bool GRobotSpeedControl::has_nodename() const {
  return _has_bit(5);
}
inline void GRobotSpeedControl::clear_nodename() {
  if (nodename_ != &_default_nodename_) {
    nodename_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& GRobotSpeedControl::nodename() const {
  return *nodename_;
}
inline void GRobotSpeedControl::set_nodename(const ::std::string& value) {
  _set_bit(5);
  if (nodename_ == &_default_nodename_) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void GRobotSpeedControl::set_nodename(const char* value) {
  _set_bit(5);
  if (nodename_ == &_default_nodename_) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void GRobotSpeedControl::set_nodename(const char* value, size_t size) {
  _set_bit(5);
  if (nodename_ == &_default_nodename_) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GRobotSpeedControl::mutable_nodename() {
  _set_bit(5);
  if (nodename_ == &_default_nodename_) {
    nodename_ = new ::std::string;
  }
  return nodename_;
}

// -------------------------------------------------------------------

// GOdometer

// optional .GOdometer.OdometerMode mode = 1;
inline bool GOdometer::has_mode() const {
  return _has_bit(0);
}
inline void GOdometer::clear_mode() {
  mode_ = 1;
  _clear_bit(0);
}
inline ::GOdometer_OdometerMode GOdometer::mode() const {
  return static_cast< ::GOdometer_OdometerMode >(mode_);
}
inline void GOdometer::set_mode(::GOdometer_OdometerMode value) {
  GOOGLE_DCHECK(::GOdometer_OdometerMode_IsValid(value));
  _set_bit(0);
  mode_ = value;
}

// optional double x = 2;
inline bool GOdometer::has_x() const {
  return _has_bit(1);
}
inline void GOdometer::clear_x() {
  x_ = 0;
  _clear_bit(1);
}
inline double GOdometer::x() const {
  return x_;
}
inline void GOdometer::set_x(double value) {
  _set_bit(1);
  x_ = value;
}

// optional double y = 3;
inline bool GOdometer::has_y() const {
  return _has_bit(2);
}
inline void GOdometer::clear_y() {
  y_ = 0;
  _clear_bit(2);
}
inline double GOdometer::y() const {
  return y_;
}
inline void GOdometer::set_y(double value) {
  _set_bit(2);
  y_ = value;
}

// optional double angle = 4;
inline bool GOdometer::has_angle() const {
  return _has_bit(3);
}
inline void GOdometer::clear_angle() {
  angle_ = 0;
  _clear_bit(3);
}
inline double GOdometer::angle() const {
  return angle_;
}
inline void GOdometer::set_angle(double value) {
  _set_bit(3);
  angle_ = value;
}

// repeated .GMotorSet motors = 5;
inline int GOdometer::motors_size() const {
  return motors_.size();
}
inline void GOdometer::clear_motors() {
  motors_.Clear();
}
inline const ::GMotorSet& GOdometer::motors(int index) const {
  return motors_.Get(index);
}
inline ::GMotorSet* GOdometer::mutable_motors(int index) {
  return motors_.Mutable(index);
}
inline ::GMotorSet* GOdometer::add_motors() {
  return motors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GMotorSet >&
GOdometer::motors() const {
  return motors_;
}
inline ::google::protobuf::RepeatedPtrField< ::GMotorSet >*
GOdometer::mutable_motors() {
  return &motors_;
}

// -------------------------------------------------------------------

// GChassicData

// optional .GOdometer odometer = 1;
inline bool GChassicData::has_odometer() const {
  return _has_bit(0);
}
inline void GChassicData::clear_odometer() {
  if (odometer_ != NULL) odometer_->::GOdometer::Clear();
  _clear_bit(0);
}
inline const ::GOdometer& GChassicData::odometer() const {
  return odometer_ != NULL ? *odometer_ : *default_instance_->odometer_;
}
inline ::GOdometer* GChassicData::mutable_odometer() {
  _set_bit(0);
  if (odometer_ == NULL) odometer_ = new ::GOdometer;
  return odometer_;
}

// optional .GRobotSpeed speed = 2;
inline bool GChassicData::has_speed() const {
  return _has_bit(1);
}
inline void GChassicData::clear_speed() {
  if (speed_ != NULL) speed_->::GRobotSpeed::Clear();
  _clear_bit(1);
}
inline const ::GRobotSpeed& GChassicData::speed() const {
  return speed_ != NULL ? *speed_ : *default_instance_->speed_;
}
inline ::GRobotSpeed* GChassicData::mutable_speed() {
  _set_bit(1);
  if (speed_ == NULL) speed_ = new ::GRobotSpeed;
  return speed_;
}

// optional .GRobotPWM pwm = 3;
inline bool GChassicData::has_pwm() const {
  return _has_bit(2);
}
inline void GChassicData::clear_pwm() {
  if (pwm_ != NULL) pwm_->::GRobotPWM::Clear();
  _clear_bit(2);
}
inline const ::GRobotPWM& GChassicData::pwm() const {
  return pwm_ != NULL ? *pwm_ : *default_instance_->pwm_;
}
inline ::GRobotPWM* GChassicData::mutable_pwm() {
  _set_bit(2);
  if (pwm_ == NULL) pwm_ = new ::GRobotPWM;
  return pwm_;
}

// optional double time_stamp = 4;
inline bool GChassicData::has_time_stamp() const {
  return _has_bit(3);
}
inline void GChassicData::clear_time_stamp() {
  time_stamp_ = 0;
  _clear_bit(3);
}
inline double GChassicData::time_stamp() const {
  return time_stamp_;
}
inline void GChassicData::set_time_stamp(double value) {
  _set_bit(3);
  time_stamp_ = value;
}

// -------------------------------------------------------------------

// GMotorDebugMessage

// required int32 id = 1;
inline bool GMotorDebugMessage::has_id() const {
  return _has_bit(0);
}
inline void GMotorDebugMessage::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 GMotorDebugMessage::id() const {
  return id_;
}
inline void GMotorDebugMessage::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional double current = 2;
inline bool GMotorDebugMessage::has_current() const {
  return _has_bit(1);
}
inline void GMotorDebugMessage::clear_current() {
  current_ = 0;
  _clear_bit(1);
}
inline double GMotorDebugMessage::current() const {
  return current_;
}
inline void GMotorDebugMessage::set_current(double value) {
  _set_bit(1);
  current_ = value;
}

// optional double voltage = 3;
inline bool GMotorDebugMessage::has_voltage() const {
  return _has_bit(2);
}
inline void GMotorDebugMessage::clear_voltage() {
  voltage_ = 0;
  _clear_bit(2);
}
inline double GMotorDebugMessage::voltage() const {
  return voltage_;
}
inline void GMotorDebugMessage::set_voltage(double value) {
  _set_bit(2);
  voltage_ = value;
}

// optional double targetVel = 4;
inline bool GMotorDebugMessage::has_targetvel() const {
  return _has_bit(3);
}
inline void GMotorDebugMessage::clear_targetvel() {
  targetvel_ = 0;
  _clear_bit(3);
}
inline double GMotorDebugMessage::targetvel() const {
  return targetvel_;
}
inline void GMotorDebugMessage::set_targetvel(double value) {
  _set_bit(3);
  targetvel_ = value;
}

// optional double actualVel = 5;
inline bool GMotorDebugMessage::has_actualvel() const {
  return _has_bit(4);
}
inline void GMotorDebugMessage::clear_actualvel() {
  actualvel_ = 0;
  _clear_bit(4);
}
inline double GMotorDebugMessage::actualvel() const {
  return actualvel_;
}
inline void GMotorDebugMessage::set_actualvel(double value) {
  _set_bit(4);
  actualvel_ = value;
}

// optional string description = 6;
inline bool GMotorDebugMessage::has_description() const {
  return _has_bit(5);
}
inline void GMotorDebugMessage::clear_description() {
  if (description_ != &_default_description_) {
    description_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& GMotorDebugMessage::description() const {
  return *description_;
}
inline void GMotorDebugMessage::set_description(const ::std::string& value) {
  _set_bit(5);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void GMotorDebugMessage::set_description(const char* value) {
  _set_bit(5);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void GMotorDebugMessage::set_description(const char* value, size_t size) {
  _set_bit(5);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMotorDebugMessage::mutable_description() {
  _set_bit(5);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  return description_;
}

// optional int32 errorType = 7;
inline bool GMotorDebugMessage::has_errortype() const {
  return _has_bit(6);
}
inline void GMotorDebugMessage::clear_errortype() {
  errortype_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 GMotorDebugMessage::errortype() const {
  return errortype_;
}
inline void GMotorDebugMessage::set_errortype(::google::protobuf::int32 value) {
  _set_bit(6);
  errortype_ = value;
}

// -------------------------------------------------------------------

// GChassicDebugMessage

// optional int32 errorType = 1;
inline bool GChassicDebugMessage::has_errortype() const {
  return _has_bit(0);
}
inline void GChassicDebugMessage::clear_errortype() {
  errortype_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 GChassicDebugMessage::errortype() const {
  return errortype_;
}
inline void GChassicDebugMessage::set_errortype(::google::protobuf::int32 value) {
  _set_bit(0);
  errortype_ = value;
}

// optional string errorDesption = 2;
inline bool GChassicDebugMessage::has_errordesption() const {
  return _has_bit(1);
}
inline void GChassicDebugMessage::clear_errordesption() {
  if (errordesption_ != &_default_errordesption_) {
    errordesption_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GChassicDebugMessage::errordesption() const {
  return *errordesption_;
}
inline void GChassicDebugMessage::set_errordesption(const ::std::string& value) {
  _set_bit(1);
  if (errordesption_ == &_default_errordesption_) {
    errordesption_ = new ::std::string;
  }
  errordesption_->assign(value);
}
inline void GChassicDebugMessage::set_errordesption(const char* value) {
  _set_bit(1);
  if (errordesption_ == &_default_errordesption_) {
    errordesption_ = new ::std::string;
  }
  errordesption_->assign(value);
}
inline void GChassicDebugMessage::set_errordesption(const char* value, size_t size) {
  _set_bit(1);
  if (errordesption_ == &_default_errordesption_) {
    errordesption_ = new ::std::string;
  }
  errordesption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GChassicDebugMessage::mutable_errordesption() {
  _set_bit(1);
  if (errordesption_ == &_default_errordesption_) {
    errordesption_ = new ::std::string;
  }
  return errordesption_;
}

// repeated .GMotorDebugMessage motors = 3;
inline int GChassicDebugMessage::motors_size() const {
  return motors_.size();
}
inline void GChassicDebugMessage::clear_motors() {
  motors_.Clear();
}
inline const ::GMotorDebugMessage& GChassicDebugMessage::motors(int index) const {
  return motors_.Get(index);
}
inline ::GMotorDebugMessage* GChassicDebugMessage::mutable_motors(int index) {
  return motors_.Mutable(index);
}
inline ::GMotorDebugMessage* GChassicDebugMessage::add_motors() {
  return motors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GMotorDebugMessage >&
GChassicDebugMessage::motors() const {
  return motors_;
}
inline ::google::protobuf::RepeatedPtrField< ::GMotorDebugMessage >*
GChassicDebugMessage::mutable_motors() {
  return &motors_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GRobotSpeed_ControlMode>() {
  return ::GRobotSpeed_ControlMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GRobotSpeedControl_RobotSpeedControlType>() {
  return ::GRobotSpeedControl_RobotSpeedControlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GOdometer_OdometerMode>() {
  return ::GOdometer_OdometerMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GChassic_2eproto__INCLUDED
