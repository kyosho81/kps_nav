// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GTraceList.proto

#ifndef PROTOBUF_GTraceList_2eproto__INCLUDED
#define PROTOBUF_GTraceList_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GTraceList_2eproto();
void protobuf_AssignDesc_GTraceList_2eproto();
void protobuf_ShutdownFile_GTraceList_2eproto();

class GTracePoint;
class GTraceSeg;
class GTraceList;

enum GTraceList_ExecuteStatus {
  GTraceList_ExecuteStatus_EXECUTE_STATUS_IDLE = 1,
  GTraceList_ExecuteStatus_EXECUTE_STATUS_TRACE = 2,
  GTraceList_ExecuteStatus_EXECUTE_STATUS_BLOCKED = 3,
  GTraceList_ExecuteStatus_EXECUTE_STATUS_CIRCUMVENT = 4,
  GTraceList_ExecuteStatus_EXECUTE_STATUS_FINISHED = 5,
  GTraceList_ExecuteStatus_EXECUTE_STATUS_EXCEPTION = 6,
  GTraceList_ExecuteStatus_EXECUTE_STATUS_MAX = 7
};
bool GTraceList_ExecuteStatus_IsValid(int value);
const GTraceList_ExecuteStatus GTraceList_ExecuteStatus_ExecuteStatus_MIN = GTraceList_ExecuteStatus_EXECUTE_STATUS_IDLE;
const GTraceList_ExecuteStatus GTraceList_ExecuteStatus_ExecuteStatus_MAX = GTraceList_ExecuteStatus_EXECUTE_STATUS_MAX;
const int GTraceList_ExecuteStatus_ExecuteStatus_ARRAYSIZE = GTraceList_ExecuteStatus_ExecuteStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* GTraceList_ExecuteStatus_descriptor();
inline const ::std::string& GTraceList_ExecuteStatus_Name(GTraceList_ExecuteStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    GTraceList_ExecuteStatus_descriptor(), value);
}
inline bool GTraceList_ExecuteStatus_Parse(
    const ::std::string& name, GTraceList_ExecuteStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GTraceList_ExecuteStatus>(
    GTraceList_ExecuteStatus_descriptor(), name, value);
}
// ===================================================================

class GTracePoint : public ::google::protobuf::Message {
 public:
  GTracePoint();
  virtual ~GTracePoint();
  
  GTracePoint(const GTracePoint& from);
  
  inline GTracePoint& operator=(const GTracePoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GTracePoint& default_instance();
  
  void Swap(GTracePoint* other);
  
  // implements Message ----------------------------------------------
  
  GTracePoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GTracePoint& from);
  void MergeFrom(const GTracePoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);
  
  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);
  
  // required double angle = 3;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 3;
  inline double angle() const;
  inline void set_angle(double value);
  
  // optional double speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline double speed() const;
  inline void set_speed(double value);
  
  // optional int32 starter = 5;
  inline bool has_starter() const;
  inline void clear_starter();
  static const int kStarterFieldNumber = 5;
  inline ::google::protobuf::int32 starter() const;
  inline void set_starter(::google::protobuf::int32 value);
  
  // optional string desc = 6;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 6;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  
  // @@protoc_insertion_point(class_scope:GTracePoint)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double x_;
  double y_;
  double angle_;
  double speed_;
  ::google::protobuf::int32 starter_;
  ::std::string* desc_;
  static const ::std::string _default_desc_;
  friend void  protobuf_AddDesc_GTraceList_2eproto();
  friend void protobuf_AssignDesc_GTraceList_2eproto();
  friend void protobuf_ShutdownFile_GTraceList_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GTracePoint* default_instance_;
};
// -------------------------------------------------------------------

class GTraceSeg : public ::google::protobuf::Message {
 public:
  GTraceSeg();
  virtual ~GTraceSeg();
  
  GTraceSeg(const GTraceSeg& from);
  
  inline GTraceSeg& operator=(const GTraceSeg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GTraceSeg& default_instance();
  
  void Swap(GTraceSeg* other);
  
  // implements Message ----------------------------------------------
  
  GTraceSeg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GTraceSeg& from);
  void MergeFrom(const GTraceSeg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GTracePoint first = 1;
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 1;
  inline const ::GTracePoint& first() const;
  inline ::GTracePoint* mutable_first();
  
  // required .GTracePoint second = 2;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 2;
  inline const ::GTracePoint& second() const;
  inline ::GTracePoint* mutable_second();
  
  // required double finished = 3;
  inline bool has_finished() const;
  inline void clear_finished();
  static const int kFinishedFieldNumber = 3;
  inline double finished() const;
  inline void set_finished(double value);
  
  // @@protoc_insertion_point(class_scope:GTraceSeg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::GTracePoint* first_;
  ::GTracePoint* second_;
  double finished_;
  friend void  protobuf_AddDesc_GTraceList_2eproto();
  friend void protobuf_AssignDesc_GTraceList_2eproto();
  friend void protobuf_ShutdownFile_GTraceList_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GTraceSeg* default_instance_;
};
// -------------------------------------------------------------------

class GTraceList : public ::google::protobuf::Message {
 public:
  GTraceList();
  virtual ~GTraceList();
  
  GTraceList(const GTraceList& from);
  
  inline GTraceList& operator=(const GTraceList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GTraceList& default_instance();
  
  void Swap(GTraceList* other);
  
  // implements Message ----------------------------------------------
  
  GTraceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GTraceList& from);
  void MergeFrom(const GTraceList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GTraceList_ExecuteStatus ExecuteStatus;
  static const ExecuteStatus EXECUTE_STATUS_IDLE = GTraceList_ExecuteStatus_EXECUTE_STATUS_IDLE;
  static const ExecuteStatus EXECUTE_STATUS_TRACE = GTraceList_ExecuteStatus_EXECUTE_STATUS_TRACE;
  static const ExecuteStatus EXECUTE_STATUS_BLOCKED = GTraceList_ExecuteStatus_EXECUTE_STATUS_BLOCKED;
  static const ExecuteStatus EXECUTE_STATUS_CIRCUMVENT = GTraceList_ExecuteStatus_EXECUTE_STATUS_CIRCUMVENT;
  static const ExecuteStatus EXECUTE_STATUS_FINISHED = GTraceList_ExecuteStatus_EXECUTE_STATUS_FINISHED;
  static const ExecuteStatus EXECUTE_STATUS_EXCEPTION = GTraceList_ExecuteStatus_EXECUTE_STATUS_EXCEPTION;
  static const ExecuteStatus EXECUTE_STATUS_MAX = GTraceList_ExecuteStatus_EXECUTE_STATUS_MAX;
  static inline bool ExecuteStatus_IsValid(int value) {
    return GTraceList_ExecuteStatus_IsValid(value);
  }
  static const ExecuteStatus ExecuteStatus_MIN =
    GTraceList_ExecuteStatus_ExecuteStatus_MIN;
  static const ExecuteStatus ExecuteStatus_MAX =
    GTraceList_ExecuteStatus_ExecuteStatus_MAX;
  static const int ExecuteStatus_ARRAYSIZE =
    GTraceList_ExecuteStatus_ExecuteStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExecuteStatus_descriptor() {
    return GTraceList_ExecuteStatus_descriptor();
  }
  static inline const ::std::string& ExecuteStatus_Name(ExecuteStatus value) {
    return GTraceList_ExecuteStatus_Name(value);
  }
  static inline bool ExecuteStatus_Parse(const ::std::string& name,
      ExecuteStatus* value) {
    return GTraceList_ExecuteStatus_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // repeated .GTraceSeg lists = 1;
  inline int lists_size() const;
  inline void clear_lists();
  static const int kListsFieldNumber = 1;
  inline const ::GTraceSeg& lists(int index) const;
  inline ::GTraceSeg* mutable_lists(int index);
  inline ::GTraceSeg* add_lists();
  inline const ::google::protobuf::RepeatedPtrField< ::GTraceSeg >&
      lists() const;
  inline ::google::protobuf::RepeatedPtrField< ::GTraceSeg >*
      mutable_lists();
  
  // required bytes map = 2;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 2;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const void* value, size_t size);
  inline ::std::string* mutable_map();
  
  // optional .GTraceList.ExecuteStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::GTraceList_ExecuteStatus status() const;
  inline void set_status(::GTraceList_ExecuteStatus value);
  
  // @@protoc_insertion_point(class_scope:GTraceList)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::GTraceSeg > lists_;
  ::std::string* map_;
  static const ::std::string _default_map_;
  int status_;
  friend void  protobuf_AddDesc_GTraceList_2eproto();
  friend void protobuf_AssignDesc_GTraceList_2eproto();
  friend void protobuf_ShutdownFile_GTraceList_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GTraceList* default_instance_;
};
// ===================================================================


// ===================================================================

// GTracePoint

// required double x = 1;
inline bool GTracePoint::has_x() const {
  return _has_bit(0);
}
inline void GTracePoint::clear_x() {
  x_ = 0;
  _clear_bit(0);
}
inline double GTracePoint::x() const {
  return x_;
}
inline void GTracePoint::set_x(double value) {
  _set_bit(0);
  x_ = value;
}

// required double y = 2;
inline bool GTracePoint::has_y() const {
  return _has_bit(1);
}
inline void GTracePoint::clear_y() {
  y_ = 0;
  _clear_bit(1);
}
inline double GTracePoint::y() const {
  return y_;
}
inline void GTracePoint::set_y(double value) {
  _set_bit(1);
  y_ = value;
}

// required double angle = 3;
inline bool GTracePoint::has_angle() const {
  return _has_bit(2);
}
inline void GTracePoint::clear_angle() {
  angle_ = 0;
  _clear_bit(2);
}
inline double GTracePoint::angle() const {
  return angle_;
}
inline void GTracePoint::set_angle(double value) {
  _set_bit(2);
  angle_ = value;
}

// optional double speed = 4;
inline bool GTracePoint::has_speed() const {
  return _has_bit(3);
}
inline void GTracePoint::clear_speed() {
  speed_ = 0;
  _clear_bit(3);
}
inline double GTracePoint::speed() const {
  return speed_;
}
inline void GTracePoint::set_speed(double value) {
  _set_bit(3);
  speed_ = value;
}

// optional int32 starter = 5;
inline bool GTracePoint::has_starter() const {
  return _has_bit(4);
}
inline void GTracePoint::clear_starter() {
  starter_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 GTracePoint::starter() const {
  return starter_;
}
inline void GTracePoint::set_starter(::google::protobuf::int32 value) {
  _set_bit(4);
  starter_ = value;
}

// optional string desc = 6;
inline bool GTracePoint::has_desc() const {
  return _has_bit(5);
}
inline void GTracePoint::clear_desc() {
  if (desc_ != &_default_desc_) {
    desc_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& GTracePoint::desc() const {
  return *desc_;
}
inline void GTracePoint::set_desc(const ::std::string& value) {
  _set_bit(5);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void GTracePoint::set_desc(const char* value) {
  _set_bit(5);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void GTracePoint::set_desc(const char* value, size_t size) {
  _set_bit(5);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GTracePoint::mutable_desc() {
  _set_bit(5);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  return desc_;
}

// -------------------------------------------------------------------

// GTraceSeg

// required .GTracePoint first = 1;
inline bool GTraceSeg::has_first() const {
  return _has_bit(0);
}
inline void GTraceSeg::clear_first() {
  if (first_ != NULL) first_->::GTracePoint::Clear();
  _clear_bit(0);
}
inline const ::GTracePoint& GTraceSeg::first() const {
  return first_ != NULL ? *first_ : *default_instance_->first_;
}
inline ::GTracePoint* GTraceSeg::mutable_first() {
  _set_bit(0);
  if (first_ == NULL) first_ = new ::GTracePoint;
  return first_;
}

// required .GTracePoint second = 2;
inline bool GTraceSeg::has_second() const {
  return _has_bit(1);
}
inline void GTraceSeg::clear_second() {
  if (second_ != NULL) second_->::GTracePoint::Clear();
  _clear_bit(1);
}
inline const ::GTracePoint& GTraceSeg::second() const {
  return second_ != NULL ? *second_ : *default_instance_->second_;
}
inline ::GTracePoint* GTraceSeg::mutable_second() {
  _set_bit(1);
  if (second_ == NULL) second_ = new ::GTracePoint;
  return second_;
}

// required double finished = 3;
inline bool GTraceSeg::has_finished() const {
  return _has_bit(2);
}
inline void GTraceSeg::clear_finished() {
  finished_ = 0;
  _clear_bit(2);
}
inline double GTraceSeg::finished() const {
  return finished_;
}
inline void GTraceSeg::set_finished(double value) {
  _set_bit(2);
  finished_ = value;
}

// -------------------------------------------------------------------

// GTraceList

// repeated .GTraceSeg lists = 1;
inline int GTraceList::lists_size() const {
  return lists_.size();
}
inline void GTraceList::clear_lists() {
  lists_.Clear();
}
inline const ::GTraceSeg& GTraceList::lists(int index) const {
  return lists_.Get(index);
}
inline ::GTraceSeg* GTraceList::mutable_lists(int index) {
  return lists_.Mutable(index);
}
inline ::GTraceSeg* GTraceList::add_lists() {
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GTraceSeg >&
GTraceList::lists() const {
  return lists_;
}
inline ::google::protobuf::RepeatedPtrField< ::GTraceSeg >*
GTraceList::mutable_lists() {
  return &lists_;
}

// required bytes map = 2;
inline bool GTraceList::has_map() const {
  return _has_bit(1);
}
inline void GTraceList::clear_map() {
  if (map_ != &_default_map_) {
    map_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GTraceList::map() const {
  return *map_;
}
inline void GTraceList::set_map(const ::std::string& value) {
  _set_bit(1);
  if (map_ == &_default_map_) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void GTraceList::set_map(const char* value) {
  _set_bit(1);
  if (map_ == &_default_map_) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void GTraceList::set_map(const void* value, size_t size) {
  _set_bit(1);
  if (map_ == &_default_map_) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GTraceList::mutable_map() {
  _set_bit(1);
  if (map_ == &_default_map_) {
    map_ = new ::std::string;
  }
  return map_;
}

// optional .GTraceList.ExecuteStatus status = 3;
inline bool GTraceList::has_status() const {
  return _has_bit(2);
}
inline void GTraceList::clear_status() {
  status_ = 1;
  _clear_bit(2);
}
inline ::GTraceList_ExecuteStatus GTraceList::status() const {
  return static_cast< ::GTraceList_ExecuteStatus >(status_);
}
inline void GTraceList::set_status(::GTraceList_ExecuteStatus value) {
  GOOGLE_DCHECK(::GTraceList_ExecuteStatus_IsValid(value));
  _set_bit(2);
  status_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GTraceList_ExecuteStatus>() {
  return ::GTraceList_ExecuteStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GTraceList_2eproto__INCLUDED
