// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: seg_path.proto

#ifndef PROTOBUF_seg_5fpath_2eproto__INCLUDED
#define PROTOBUF_seg_5fpath_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace KPS {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_seg_5fpath_2eproto();
void protobuf_AssignDesc_seg_5fpath_2eproto();
void protobuf_ShutdownFile_seg_5fpath_2eproto();

class mp_seg_path_data;
class mp_seg_path;

enum mp_seg_path_data_Seg_Type {
  mp_seg_path_data_Seg_Type_PATH_SEG = 0,
  mp_seg_path_data_Seg_Type_PATH_ROT = 1,
  mp_seg_path_data_Seg_Type_PATH_ARC = 2
};
bool mp_seg_path_data_Seg_Type_IsValid(int value);
const mp_seg_path_data_Seg_Type mp_seg_path_data_Seg_Type_Seg_Type_MIN = mp_seg_path_data_Seg_Type_PATH_SEG;
const mp_seg_path_data_Seg_Type mp_seg_path_data_Seg_Type_Seg_Type_MAX = mp_seg_path_data_Seg_Type_PATH_ARC;
const int mp_seg_path_data_Seg_Type_Seg_Type_ARRAYSIZE = mp_seg_path_data_Seg_Type_Seg_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* mp_seg_path_data_Seg_Type_descriptor();
inline const ::std::string& mp_seg_path_data_Seg_Type_Name(mp_seg_path_data_Seg_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    mp_seg_path_data_Seg_Type_descriptor(), value);
}
inline bool mp_seg_path_data_Seg_Type_Parse(
    const ::std::string& name, mp_seg_path_data_Seg_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<mp_seg_path_data_Seg_Type>(
    mp_seg_path_data_Seg_Type_descriptor(), name, value);
}
// ===================================================================

class mp_seg_path_data : public ::google::protobuf::Message {
 public:
  mp_seg_path_data();
  virtual ~mp_seg_path_data();
  
  mp_seg_path_data(const mp_seg_path_data& from);
  
  inline mp_seg_path_data& operator=(const mp_seg_path_data& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mp_seg_path_data& default_instance();
  
  void Swap(mp_seg_path_data* other);
  
  // implements Message ----------------------------------------------
  
  mp_seg_path_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mp_seg_path_data& from);
  void MergeFrom(const mp_seg_path_data& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef mp_seg_path_data_Seg_Type Seg_Type;
  static const Seg_Type PATH_SEG = mp_seg_path_data_Seg_Type_PATH_SEG;
  static const Seg_Type PATH_ROT = mp_seg_path_data_Seg_Type_PATH_ROT;
  static const Seg_Type PATH_ARC = mp_seg_path_data_Seg_Type_PATH_ARC;
  static inline bool Seg_Type_IsValid(int value) {
    return mp_seg_path_data_Seg_Type_IsValid(value);
  }
  static const Seg_Type Seg_Type_MIN =
    mp_seg_path_data_Seg_Type_Seg_Type_MIN;
  static const Seg_Type Seg_Type_MAX =
    mp_seg_path_data_Seg_Type_Seg_Type_MAX;
  static const int Seg_Type_ARRAYSIZE =
    mp_seg_path_data_Seg_Type_Seg_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Seg_Type_descriptor() {
    return mp_seg_path_data_Seg_Type_descriptor();
  }
  static inline const ::std::string& Seg_Type_Name(Seg_Type value) {
    return mp_seg_path_data_Seg_Type_Name(value);
  }
  static inline bool Seg_Type_Parse(const ::std::string& name,
      Seg_Type* value) {
    return mp_seg_path_data_Seg_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required float x1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline float x1() const;
  inline void set_x1(float value);
  
  // required float y1 = 2;
  inline bool has_y1() const;
  inline void clear_y1();
  static const int kY1FieldNumber = 2;
  inline float y1() const;
  inline void set_y1(float value);
  
  // required float th1 = 3;
  inline bool has_th1() const;
  inline void clear_th1();
  static const int kTh1FieldNumber = 3;
  inline float th1() const;
  inline void set_th1(float value);
  
  // required float x2 = 4;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 4;
  inline float x2() const;
  inline void set_x2(float value);
  
  // required float y2 = 5;
  inline bool has_y2() const;
  inline void clear_y2();
  static const int kY2FieldNumber = 5;
  inline float y2() const;
  inline void set_y2(float value);
  
  // required float th2 = 6;
  inline bool has_th2() const;
  inline void clear_th2();
  static const int kTh2FieldNumber = 6;
  inline float th2() const;
  inline void set_th2(float value);
  
  // required .KPS.mp_seg_path_data.Seg_Type p_type = 7;
  inline bool has_p_type() const;
  inline void clear_p_type();
  static const int kPTypeFieldNumber = 7;
  inline ::KPS::mp_seg_path_data_Seg_Type p_type() const;
  inline void set_p_type(::KPS::mp_seg_path_data_Seg_Type value);
  
  // required float complete = 8;
  inline bool has_complete() const;
  inline void clear_complete();
  static const int kCompleteFieldNumber = 8;
  inline float complete() const;
  inline void set_complete(float value);
  
  // required float speed = 9;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 9;
  inline float speed() const;
  inline void set_speed(float value);
  
  // @@protoc_insertion_point(class_scope:KPS.mp_seg_path_data)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float x1_;
  float y1_;
  float th1_;
  float x2_;
  float y2_;
  float th2_;
  int p_type_;
  float complete_;
  float speed_;
  friend void  protobuf_AddDesc_seg_5fpath_2eproto();
  friend void protobuf_AssignDesc_seg_5fpath_2eproto();
  friend void protobuf_ShutdownFile_seg_5fpath_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mp_seg_path_data* default_instance_;
};
// -------------------------------------------------------------------

class mp_seg_path : public ::google::protobuf::Message {
 public:
  mp_seg_path();
  virtual ~mp_seg_path();
  
  mp_seg_path(const mp_seg_path& from);
  
  inline mp_seg_path& operator=(const mp_seg_path& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mp_seg_path& default_instance();
  
  void Swap(mp_seg_path* other);
  
  // implements Message ----------------------------------------------
  
  mp_seg_path* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mp_seg_path& from);
  void MergeFrom(const mp_seg_path& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string seg_path_name = 1;
  inline bool has_seg_path_name() const;
  inline void clear_seg_path_name();
  static const int kSegPathNameFieldNumber = 1;
  inline const ::std::string& seg_path_name() const;
  inline void set_seg_path_name(const ::std::string& value);
  inline void set_seg_path_name(const char* value);
  inline void set_seg_path_name(const char* value, size_t size);
  inline ::std::string* mutable_seg_path_name();
  
  // repeated .KPS.mp_seg_path_data data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::KPS::mp_seg_path_data& data(int index) const;
  inline ::KPS::mp_seg_path_data* mutable_data(int index);
  inline ::KPS::mp_seg_path_data* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::KPS::mp_seg_path_data >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::KPS::mp_seg_path_data >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:KPS.mp_seg_path)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* seg_path_name_;
  static const ::std::string _default_seg_path_name_;
  ::google::protobuf::RepeatedPtrField< ::KPS::mp_seg_path_data > data_;
  friend void  protobuf_AddDesc_seg_5fpath_2eproto();
  friend void protobuf_AssignDesc_seg_5fpath_2eproto();
  friend void protobuf_ShutdownFile_seg_5fpath_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mp_seg_path* default_instance_;
};
// ===================================================================


// ===================================================================

// mp_seg_path_data

// required float x1 = 1;
inline bool mp_seg_path_data::has_x1() const {
  return _has_bit(0);
}
inline void mp_seg_path_data::clear_x1() {
  x1_ = 0;
  _clear_bit(0);
}
inline float mp_seg_path_data::x1() const {
  return x1_;
}
inline void mp_seg_path_data::set_x1(float value) {
  _set_bit(0);
  x1_ = value;
}

// required float y1 = 2;
inline bool mp_seg_path_data::has_y1() const {
  return _has_bit(1);
}
inline void mp_seg_path_data::clear_y1() {
  y1_ = 0;
  _clear_bit(1);
}
inline float mp_seg_path_data::y1() const {
  return y1_;
}
inline void mp_seg_path_data::set_y1(float value) {
  _set_bit(1);
  y1_ = value;
}

// required float th1 = 3;
inline bool mp_seg_path_data::has_th1() const {
  return _has_bit(2);
}
inline void mp_seg_path_data::clear_th1() {
  th1_ = 0;
  _clear_bit(2);
}
inline float mp_seg_path_data::th1() const {
  return th1_;
}
inline void mp_seg_path_data::set_th1(float value) {
  _set_bit(2);
  th1_ = value;
}

// required float x2 = 4;
inline bool mp_seg_path_data::has_x2() const {
  return _has_bit(3);
}
inline void mp_seg_path_data::clear_x2() {
  x2_ = 0;
  _clear_bit(3);
}
inline float mp_seg_path_data::x2() const {
  return x2_;
}
inline void mp_seg_path_data::set_x2(float value) {
  _set_bit(3);
  x2_ = value;
}

// required float y2 = 5;
inline bool mp_seg_path_data::has_y2() const {
  return _has_bit(4);
}
inline void mp_seg_path_data::clear_y2() {
  y2_ = 0;
  _clear_bit(4);
}
inline float mp_seg_path_data::y2() const {
  return y2_;
}
inline void mp_seg_path_data::set_y2(float value) {
  _set_bit(4);
  y2_ = value;
}

// required float th2 = 6;
inline bool mp_seg_path_data::has_th2() const {
  return _has_bit(5);
}
inline void mp_seg_path_data::clear_th2() {
  th2_ = 0;
  _clear_bit(5);
}
inline float mp_seg_path_data::th2() const {
  return th2_;
}
inline void mp_seg_path_data::set_th2(float value) {
  _set_bit(5);
  th2_ = value;
}

// required .KPS.mp_seg_path_data.Seg_Type p_type = 7;
inline bool mp_seg_path_data::has_p_type() const {
  return _has_bit(6);
}
inline void mp_seg_path_data::clear_p_type() {
  p_type_ = 0;
  _clear_bit(6);
}
inline ::KPS::mp_seg_path_data_Seg_Type mp_seg_path_data::p_type() const {
  return static_cast< ::KPS::mp_seg_path_data_Seg_Type >(p_type_);
}
inline void mp_seg_path_data::set_p_type(::KPS::mp_seg_path_data_Seg_Type value) {
  GOOGLE_DCHECK(::KPS::mp_seg_path_data_Seg_Type_IsValid(value));
  _set_bit(6);
  p_type_ = value;
}

// required float complete = 8;
inline bool mp_seg_path_data::has_complete() const {
  return _has_bit(7);
}
inline void mp_seg_path_data::clear_complete() {
  complete_ = 0;
  _clear_bit(7);
}
inline float mp_seg_path_data::complete() const {
  return complete_;
}
inline void mp_seg_path_data::set_complete(float value) {
  _set_bit(7);
  complete_ = value;
}

// required float speed = 9;
inline bool mp_seg_path_data::has_speed() const {
  return _has_bit(8);
}
inline void mp_seg_path_data::clear_speed() {
  speed_ = 0;
  _clear_bit(8);
}
inline float mp_seg_path_data::speed() const {
  return speed_;
}
inline void mp_seg_path_data::set_speed(float value) {
  _set_bit(8);
  speed_ = value;
}

// -------------------------------------------------------------------

// mp_seg_path

// required string seg_path_name = 1;
inline bool mp_seg_path::has_seg_path_name() const {
  return _has_bit(0);
}
inline void mp_seg_path::clear_seg_path_name() {
  if (seg_path_name_ != &_default_seg_path_name_) {
    seg_path_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& mp_seg_path::seg_path_name() const {
  return *seg_path_name_;
}
inline void mp_seg_path::set_seg_path_name(const ::std::string& value) {
  _set_bit(0);
  if (seg_path_name_ == &_default_seg_path_name_) {
    seg_path_name_ = new ::std::string;
  }
  seg_path_name_->assign(value);
}
inline void mp_seg_path::set_seg_path_name(const char* value) {
  _set_bit(0);
  if (seg_path_name_ == &_default_seg_path_name_) {
    seg_path_name_ = new ::std::string;
  }
  seg_path_name_->assign(value);
}
inline void mp_seg_path::set_seg_path_name(const char* value, size_t size) {
  _set_bit(0);
  if (seg_path_name_ == &_default_seg_path_name_) {
    seg_path_name_ = new ::std::string;
  }
  seg_path_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mp_seg_path::mutable_seg_path_name() {
  _set_bit(0);
  if (seg_path_name_ == &_default_seg_path_name_) {
    seg_path_name_ = new ::std::string;
  }
  return seg_path_name_;
}

// repeated .KPS.mp_seg_path_data data = 2;
inline int mp_seg_path::data_size() const {
  return data_.size();
}
inline void mp_seg_path::clear_data() {
  data_.Clear();
}
inline const ::KPS::mp_seg_path_data& mp_seg_path::data(int index) const {
  return data_.Get(index);
}
inline ::KPS::mp_seg_path_data* mp_seg_path::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::KPS::mp_seg_path_data* mp_seg_path::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KPS::mp_seg_path_data >&
mp_seg_path::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::KPS::mp_seg_path_data >*
mp_seg_path::mutable_data() {
  return &data_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace KPS

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KPS::mp_seg_path_data_Seg_Type>() {
  return ::KPS::mp_seg_path_data_Seg_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_seg_5fpath_2eproto__INCLUDED
