// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "log_bag.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace KPS {

namespace {

const ::google::protobuf::Descriptor* ml_log_laser_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ml_log_laser_reflection_ = NULL;
const ::google::protobuf::Descriptor* ml_log_odom_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ml_log_odom_reflection_ = NULL;
const ::google::protobuf::Descriptor* ml_log_amcl_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ml_log_amcl_reflection_ = NULL;
const ::google::protobuf::Descriptor* mb_log_bag_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  mb_log_bag_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_log_5fbag_2eproto() {
  protobuf_AddDesc_log_5fbag_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "log_bag.proto");
  GOOGLE_CHECK(file != NULL);
  ml_log_laser_descriptor_ = file->message_type(0);
  static const int ml_log_laser_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_laser, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_laser, laser_data_),
  };
  ml_log_laser_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ml_log_laser_descriptor_,
      ml_log_laser::default_instance_,
      ml_log_laser_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_laser, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_laser, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ml_log_laser));
  ml_log_odom_descriptor_ = file->message_type(1);
  static const int ml_log_odom_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_odom, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_odom, odom_),
  };
  ml_log_odom_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ml_log_odom_descriptor_,
      ml_log_odom::default_instance_,
      ml_log_odom_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_odom, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_odom, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ml_log_odom));
  ml_log_amcl_descriptor_ = file->message_type(2);
  static const int ml_log_amcl_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_amcl, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_amcl, amcl_pos_),
  };
  ml_log_amcl_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ml_log_amcl_descriptor_,
      ml_log_amcl::default_instance_,
      ml_log_amcl_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_amcl, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ml_log_amcl, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ml_log_amcl));
  mb_log_bag_descriptor_ = file->message_type(3);
  static const int mb_log_bag_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, time_stamp_begin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, time_stamp_end_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, robot_shape_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, laser_para_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, laser_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, odom_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, amcl_list_),
  };
  mb_log_bag_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      mb_log_bag_descriptor_,
      mb_log_bag::default_instance_,
      mb_log_bag_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mb_log_bag, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(mb_log_bag));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_log_5fbag_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ml_log_laser_descriptor_, &ml_log_laser::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ml_log_odom_descriptor_, &ml_log_odom::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ml_log_amcl_descriptor_, &ml_log_amcl::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    mb_log_bag_descriptor_, &mb_log_bag::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_log_5fbag_2eproto() {
  delete ml_log_laser::default_instance_;
  delete ml_log_laser_reflection_;
  delete ml_log_odom::default_instance_;
  delete ml_log_odom_reflection_;
  delete ml_log_amcl::default_instance_;
  delete ml_log_amcl_reflection_;
  delete mb_log_bag::default_instance_;
  delete mb_log_bag_reflection_;
}

void protobuf_AddDesc_log_5fbag_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::KPS::protobuf_AddDesc_laser_2eproto();
  ::KPS::protobuf_AddDesc_base_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rlog_bag.proto\022\003KPS\032\013laser.proto\032\nbase."
    "proto\"J\n\014ml_log_laser\022\022\n\ntime_stamp\030\001 \002("
    "\004\022&\n\nlaser_data\030\002 \002(\0132\022.KPS.mp_laser_dat"
    "a\"B\n\013ml_log_odom\022\022\n\ntime_stamp\030\001 \002(\004\022\037\n\004"
    "odom\030\002 \002(\0132\021.KPS.mp_odom_data\"E\n\013ml_log_"
    "amcl\022\022\n\ntime_stamp\030\001 \002(\004\022\"\n\010amcl_pos\030\002 \002"
    "(\0132\020.KPS.mp_pos_data\"\372\001\n\nmb_log_bag\022\030\n\020t"
    "ime_stamp_begin\030\001 \002(\004\022\026\n\016time_stamp_end\030"
    "\002 \002(\004\022\014\n\004time\030\003 \002(\t\022\023\n\013robot_shape\030\004 \002(\t"
    "\022&\n\nlaser_para\030\005 \002(\0132\022.KPS.mp_laser_para"
    "\022%\n\nlaser_list\030\006 \003(\0132\021.KPS.ml_log_laser\022"
    "#\n\todom_list\030\007 \003(\0132\020.KPS.ml_log_odom\022#\n\t"
    "amcl_list\030\010 \003(\0132\020.KPS.ml_log_amcl", 513);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "log_bag.proto", &protobuf_RegisterTypes);
  ml_log_laser::default_instance_ = new ml_log_laser();
  ml_log_odom::default_instance_ = new ml_log_odom();
  ml_log_amcl::default_instance_ = new ml_log_amcl();
  mb_log_bag::default_instance_ = new mb_log_bag();
  ml_log_laser::default_instance_->InitAsDefaultInstance();
  ml_log_odom::default_instance_->InitAsDefaultInstance();
  ml_log_amcl::default_instance_->InitAsDefaultInstance();
  mb_log_bag::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_log_5fbag_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_log_5fbag_2eproto {
  StaticDescriptorInitializer_log_5fbag_2eproto() {
    protobuf_AddDesc_log_5fbag_2eproto();
  }
} static_descriptor_initializer_log_5fbag_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int ml_log_laser::kTimeStampFieldNumber;
const int ml_log_laser::kLaserDataFieldNumber;
#endif  // !_MSC_VER

ml_log_laser::ml_log_laser()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ml_log_laser::InitAsDefaultInstance() {
  laser_data_ = const_cast< ::KPS::mp_laser_data*>(&::KPS::mp_laser_data::default_instance());
}

ml_log_laser::ml_log_laser(const ml_log_laser& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ml_log_laser::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = GOOGLE_ULONGLONG(0);
  laser_data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ml_log_laser::~ml_log_laser() {
  SharedDtor();
}

void ml_log_laser::SharedDtor() {
  if (this != default_instance_) {
    delete laser_data_;
  }
}

void ml_log_laser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ml_log_laser::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ml_log_laser_descriptor_;
}

const ml_log_laser& ml_log_laser::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_log_5fbag_2eproto();  return *default_instance_;
}

ml_log_laser* ml_log_laser::default_instance_ = NULL;

ml_log_laser* ml_log_laser::New() const {
  return new ml_log_laser;
}

void ml_log_laser::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_stamp_ = GOOGLE_ULONGLONG(0);
    if (_has_bit(1)) {
      if (laser_data_ != NULL) laser_data_->::KPS::mp_laser_data::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ml_log_laser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 time_stamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_stamp_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_laser_data;
        break;
      }
      
      // required .KPS.mp_laser_data laser_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_laser_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_laser_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ml_log_laser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 time_stamp = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->time_stamp(), output);
  }
  
  // required .KPS.mp_laser_data laser_data = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->laser_data(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ml_log_laser::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 time_stamp = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->time_stamp(), target);
  }
  
  // required .KPS.mp_laser_data laser_data = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->laser_data(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ml_log_laser::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time_stamp());
    }
    
    // required .KPS.mp_laser_data laser_data = 2;
    if (has_laser_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->laser_data());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ml_log_laser::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ml_log_laser* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ml_log_laser*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ml_log_laser::MergeFrom(const ml_log_laser& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_time_stamp(from.time_stamp());
    }
    if (from._has_bit(1)) {
      mutable_laser_data()->::KPS::mp_laser_data::MergeFrom(from.laser_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ml_log_laser::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ml_log_laser::CopyFrom(const ml_log_laser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ml_log_laser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_laser_data()) {
    if (!this->laser_data().IsInitialized()) return false;
  }
  return true;
}

void ml_log_laser::Swap(ml_log_laser* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(laser_data_, other->laser_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ml_log_laser::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ml_log_laser_descriptor_;
  metadata.reflection = ml_log_laser_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ml_log_odom::kTimeStampFieldNumber;
const int ml_log_odom::kOdomFieldNumber;
#endif  // !_MSC_VER

ml_log_odom::ml_log_odom()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ml_log_odom::InitAsDefaultInstance() {
  odom_ = const_cast< ::KPS::mp_odom_data*>(&::KPS::mp_odom_data::default_instance());
}

ml_log_odom::ml_log_odom(const ml_log_odom& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ml_log_odom::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = GOOGLE_ULONGLONG(0);
  odom_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ml_log_odom::~ml_log_odom() {
  SharedDtor();
}

void ml_log_odom::SharedDtor() {
  if (this != default_instance_) {
    delete odom_;
  }
}

void ml_log_odom::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ml_log_odom::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ml_log_odom_descriptor_;
}

const ml_log_odom& ml_log_odom::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_log_5fbag_2eproto();  return *default_instance_;
}

ml_log_odom* ml_log_odom::default_instance_ = NULL;

ml_log_odom* ml_log_odom::New() const {
  return new ml_log_odom;
}

void ml_log_odom::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_stamp_ = GOOGLE_ULONGLONG(0);
    if (_has_bit(1)) {
      if (odom_ != NULL) odom_->::KPS::mp_odom_data::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ml_log_odom::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 time_stamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_stamp_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_odom;
        break;
      }
      
      // required .KPS.mp_odom_data odom = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_odom:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_odom()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ml_log_odom::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 time_stamp = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->time_stamp(), output);
  }
  
  // required .KPS.mp_odom_data odom = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->odom(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ml_log_odom::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 time_stamp = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->time_stamp(), target);
  }
  
  // required .KPS.mp_odom_data odom = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->odom(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ml_log_odom::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time_stamp());
    }
    
    // required .KPS.mp_odom_data odom = 2;
    if (has_odom()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->odom());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ml_log_odom::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ml_log_odom* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ml_log_odom*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ml_log_odom::MergeFrom(const ml_log_odom& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_time_stamp(from.time_stamp());
    }
    if (from._has_bit(1)) {
      mutable_odom()->::KPS::mp_odom_data::MergeFrom(from.odom());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ml_log_odom::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ml_log_odom::CopyFrom(const ml_log_odom& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ml_log_odom::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_odom()) {
    if (!this->odom().IsInitialized()) return false;
  }
  return true;
}

void ml_log_odom::Swap(ml_log_odom* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(odom_, other->odom_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ml_log_odom::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ml_log_odom_descriptor_;
  metadata.reflection = ml_log_odom_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ml_log_amcl::kTimeStampFieldNumber;
const int ml_log_amcl::kAmclPosFieldNumber;
#endif  // !_MSC_VER

ml_log_amcl::ml_log_amcl()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ml_log_amcl::InitAsDefaultInstance() {
  amcl_pos_ = const_cast< ::KPS::mp_pos_data*>(&::KPS::mp_pos_data::default_instance());
}

ml_log_amcl::ml_log_amcl(const ml_log_amcl& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ml_log_amcl::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = GOOGLE_ULONGLONG(0);
  amcl_pos_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ml_log_amcl::~ml_log_amcl() {
  SharedDtor();
}

void ml_log_amcl::SharedDtor() {
  if (this != default_instance_) {
    delete amcl_pos_;
  }
}

void ml_log_amcl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ml_log_amcl::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ml_log_amcl_descriptor_;
}

const ml_log_amcl& ml_log_amcl::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_log_5fbag_2eproto();  return *default_instance_;
}

ml_log_amcl* ml_log_amcl::default_instance_ = NULL;

ml_log_amcl* ml_log_amcl::New() const {
  return new ml_log_amcl;
}

void ml_log_amcl::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_stamp_ = GOOGLE_ULONGLONG(0);
    if (_has_bit(1)) {
      if (amcl_pos_ != NULL) amcl_pos_->::KPS::mp_pos_data::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ml_log_amcl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 time_stamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_stamp_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_amcl_pos;
        break;
      }
      
      // required .KPS.mp_pos_data amcl_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_amcl_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_amcl_pos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ml_log_amcl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 time_stamp = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->time_stamp(), output);
  }
  
  // required .KPS.mp_pos_data amcl_pos = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->amcl_pos(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ml_log_amcl::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 time_stamp = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->time_stamp(), target);
  }
  
  // required .KPS.mp_pos_data amcl_pos = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->amcl_pos(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ml_log_amcl::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time_stamp());
    }
    
    // required .KPS.mp_pos_data amcl_pos = 2;
    if (has_amcl_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->amcl_pos());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ml_log_amcl::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ml_log_amcl* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ml_log_amcl*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ml_log_amcl::MergeFrom(const ml_log_amcl& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_time_stamp(from.time_stamp());
    }
    if (from._has_bit(1)) {
      mutable_amcl_pos()->::KPS::mp_pos_data::MergeFrom(from.amcl_pos());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ml_log_amcl::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ml_log_amcl::CopyFrom(const ml_log_amcl& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ml_log_amcl::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_amcl_pos()) {
    if (!this->amcl_pos().IsInitialized()) return false;
  }
  return true;
}

void ml_log_amcl::Swap(ml_log_amcl* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(amcl_pos_, other->amcl_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ml_log_amcl::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ml_log_amcl_descriptor_;
  metadata.reflection = ml_log_amcl_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string mb_log_bag::_default_time_;
const ::std::string mb_log_bag::_default_robot_shape_;
#ifndef _MSC_VER
const int mb_log_bag::kTimeStampBeginFieldNumber;
const int mb_log_bag::kTimeStampEndFieldNumber;
const int mb_log_bag::kTimeFieldNumber;
const int mb_log_bag::kRobotShapeFieldNumber;
const int mb_log_bag::kLaserParaFieldNumber;
const int mb_log_bag::kLaserListFieldNumber;
const int mb_log_bag::kOdomListFieldNumber;
const int mb_log_bag::kAmclListFieldNumber;
#endif  // !_MSC_VER

mb_log_bag::mb_log_bag()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void mb_log_bag::InitAsDefaultInstance() {
  laser_para_ = const_cast< ::KPS::mp_laser_para*>(&::KPS::mp_laser_para::default_instance());
}

mb_log_bag::mb_log_bag(const mb_log_bag& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void mb_log_bag::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_begin_ = GOOGLE_ULONGLONG(0);
  time_stamp_end_ = GOOGLE_ULONGLONG(0);
  time_ = const_cast< ::std::string*>(&_default_time_);
  robot_shape_ = const_cast< ::std::string*>(&_default_robot_shape_);
  laser_para_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

mb_log_bag::~mb_log_bag() {
  SharedDtor();
}

void mb_log_bag::SharedDtor() {
  if (time_ != &_default_time_) {
    delete time_;
  }
  if (robot_shape_ != &_default_robot_shape_) {
    delete robot_shape_;
  }
  if (this != default_instance_) {
    delete laser_para_;
  }
}

void mb_log_bag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* mb_log_bag::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return mb_log_bag_descriptor_;
}

const mb_log_bag& mb_log_bag::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_log_5fbag_2eproto();  return *default_instance_;
}

mb_log_bag* mb_log_bag::default_instance_ = NULL;

mb_log_bag* mb_log_bag::New() const {
  return new mb_log_bag;
}

void mb_log_bag::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_stamp_begin_ = GOOGLE_ULONGLONG(0);
    time_stamp_end_ = GOOGLE_ULONGLONG(0);
    if (_has_bit(2)) {
      if (time_ != &_default_time_) {
        time_->clear();
      }
    }
    if (_has_bit(3)) {
      if (robot_shape_ != &_default_robot_shape_) {
        robot_shape_->clear();
      }
    }
    if (_has_bit(4)) {
      if (laser_para_ != NULL) laser_para_->::KPS::mp_laser_para::Clear();
    }
  }
  laser_list_.Clear();
  odom_list_.Clear();
  amcl_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool mb_log_bag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 time_stamp_begin = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_stamp_begin_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp_end;
        break;
      }
      
      // required uint64 time_stamp_end = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time_stamp_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_stamp_end_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_time;
        break;
      }
      
      // required string time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_time()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->time().data(), this->time().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_robot_shape;
        break;
      }
      
      // required string robot_shape = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_robot_shape:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_robot_shape()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->robot_shape().data(), this->robot_shape().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_laser_para;
        break;
      }
      
      // required .KPS.mp_laser_para laser_para = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_laser_para:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_laser_para()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_laser_list;
        break;
      }
      
      // repeated .KPS.ml_log_laser laser_list = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_laser_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_laser_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_laser_list;
        if (input->ExpectTag(58)) goto parse_odom_list;
        break;
      }
      
      // repeated .KPS.ml_log_odom odom_list = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_odom_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_odom_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_odom_list;
        if (input->ExpectTag(66)) goto parse_amcl_list;
        break;
      }
      
      // repeated .KPS.ml_log_amcl amcl_list = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_amcl_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_amcl_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_amcl_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void mb_log_bag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 time_stamp_begin = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->time_stamp_begin(), output);
  }
  
  // required uint64 time_stamp_end = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->time_stamp_end(), output);
  }
  
  // required string time = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->time().data(), this->time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->time(), output);
  }
  
  // required string robot_shape = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->robot_shape().data(), this->robot_shape().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->robot_shape(), output);
  }
  
  // required .KPS.mp_laser_para laser_para = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->laser_para(), output);
  }
  
  // repeated .KPS.ml_log_laser laser_list = 6;
  for (int i = 0; i < this->laser_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->laser_list(i), output);
  }
  
  // repeated .KPS.ml_log_odom odom_list = 7;
  for (int i = 0; i < this->odom_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->odom_list(i), output);
  }
  
  // repeated .KPS.ml_log_amcl amcl_list = 8;
  for (int i = 0; i < this->amcl_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->amcl_list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* mb_log_bag::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 time_stamp_begin = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->time_stamp_begin(), target);
  }
  
  // required uint64 time_stamp_end = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->time_stamp_end(), target);
  }
  
  // required string time = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->time().data(), this->time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->time(), target);
  }
  
  // required string robot_shape = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->robot_shape().data(), this->robot_shape().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->robot_shape(), target);
  }
  
  // required .KPS.mp_laser_para laser_para = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->laser_para(), target);
  }
  
  // repeated .KPS.ml_log_laser laser_list = 6;
  for (int i = 0; i < this->laser_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->laser_list(i), target);
  }
  
  // repeated .KPS.ml_log_odom odom_list = 7;
  for (int i = 0; i < this->odom_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->odom_list(i), target);
  }
  
  // repeated .KPS.ml_log_amcl amcl_list = 8;
  for (int i = 0; i < this->amcl_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->amcl_list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int mb_log_bag::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 time_stamp_begin = 1;
    if (has_time_stamp_begin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time_stamp_begin());
    }
    
    // required uint64 time_stamp_end = 2;
    if (has_time_stamp_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time_stamp_end());
    }
    
    // required string time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->time());
    }
    
    // required string robot_shape = 4;
    if (has_robot_shape()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->robot_shape());
    }
    
    // required .KPS.mp_laser_para laser_para = 5;
    if (has_laser_para()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->laser_para());
    }
    
  }
  // repeated .KPS.ml_log_laser laser_list = 6;
  total_size += 1 * this->laser_list_size();
  for (int i = 0; i < this->laser_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->laser_list(i));
  }
  
  // repeated .KPS.ml_log_odom odom_list = 7;
  total_size += 1 * this->odom_list_size();
  for (int i = 0; i < this->odom_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->odom_list(i));
  }
  
  // repeated .KPS.ml_log_amcl amcl_list = 8;
  total_size += 1 * this->amcl_list_size();
  for (int i = 0; i < this->amcl_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->amcl_list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void mb_log_bag::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const mb_log_bag* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const mb_log_bag*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void mb_log_bag::MergeFrom(const mb_log_bag& from) {
  GOOGLE_CHECK_NE(&from, this);
  laser_list_.MergeFrom(from.laser_list_);
  odom_list_.MergeFrom(from.odom_list_);
  amcl_list_.MergeFrom(from.amcl_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_time_stamp_begin(from.time_stamp_begin());
    }
    if (from._has_bit(1)) {
      set_time_stamp_end(from.time_stamp_end());
    }
    if (from._has_bit(2)) {
      set_time(from.time());
    }
    if (from._has_bit(3)) {
      set_robot_shape(from.robot_shape());
    }
    if (from._has_bit(4)) {
      mutable_laser_para()->::KPS::mp_laser_para::MergeFrom(from.laser_para());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void mb_log_bag::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void mb_log_bag::CopyFrom(const mb_log_bag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool mb_log_bag::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  if (has_laser_para()) {
    if (!this->laser_para().IsInitialized()) return false;
  }
  for (int i = 0; i < laser_list_size(); i++) {
    if (!this->laser_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < odom_list_size(); i++) {
    if (!this->odom_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < amcl_list_size(); i++) {
    if (!this->amcl_list(i).IsInitialized()) return false;
  }
  return true;
}

void mb_log_bag::Swap(mb_log_bag* other) {
  if (other != this) {
    std::swap(time_stamp_begin_, other->time_stamp_begin_);
    std::swap(time_stamp_end_, other->time_stamp_end_);
    std::swap(time_, other->time_);
    std::swap(robot_shape_, other->robot_shape_);
    std::swap(laser_para_, other->laser_para_);
    laser_list_.Swap(&other->laser_list_);
    odom_list_.Swap(&other->odom_list_);
    amcl_list_.Swap(&other->amcl_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata mb_log_bag::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = mb_log_bag_descriptor_;
  metadata.reflection = mb_log_bag_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace KPS

// @@protoc_insertion_point(global_scope)
